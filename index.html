<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
    <meta charset="utf-8" />
    <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
    <title>Kotlin language specification</title>
    <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
    <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; position: absolute; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; }
pre.numberSource a.sourceLine:empty
  { position: absolute; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: absolute; left: -5em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
    <link rel="stylesheet" href="index.css?v=0.2.4" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
    <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
    <![endif]-->
    <script src="index.js?v=0.2.4"></script>
    $$\newcommand{\sbn}{\stackrel{null}{<:}}$$
</head>
<body>
<header>
    <h1 class="title">Kotlin language specification</h1>
</header>
<nav id="TOC">
    <ul>
        <li><a href="#glossary">Glossary</a></li>
        <li><a href="#kotlincore">Kotlin/Core</a><ul>
            <li><a href="#introduction">Introduction</a></li>
            <li><a href="#syntax">Syntax</a><ul>
                <li><a href="#grammar">Grammar</a><ul>
                    <li><a href="#lexical-grammar">Lexical grammar</a><ul>
                        <li><a href="#character-classes">Character classes</a></li>
                    </ul></li>
                </ul></li>
                <li><a href="#keywords-and-operators">Keywords and operators</a><ul>
                    <li><a href="#whitespace-and-comments">Whitespace and comments</a></li>
                    <li><a href="#number-literals">Number literals</a></li>
                    <li><a href="#identifiers">Identifiers</a></li>
                    <li><a href="#string-literals">String literals</a></li>
                    <li><a href="#syntax-grammar">Syntax grammar</a></li>
                </ul></li>
            </ul></li>
            <li><a href="#type-system">Type system</a><ul>
                <li><a href="#glossary-1">Glossary</a></li>
                <li><a href="#introduction-1">Introduction</a></li>
                <li><a href="#type-kinds">Type kinds</a><ul>
                    <li><a href="#built-in-types">Built-in types</a><ul>
                        <li><a href="#kotlin.any"><code>kotlin.Any</code></a></li>
                        <li><a href="#kotlin.nothing"><code>kotlin.Nothing</code></a></li>
                        <li><a href="#kotlin.unit"><code>kotlin.Unit</code></a></li>
                    </ul></li>
                    <li><a href="#classifier-types">Classifier types</a><ul>
                        <li><a href="#simple-classifier-types">Simple classifier types</a></li>
                        <li><a href="#parameterized-classifier-types">Parameterized classifier types</a></li>
                        <li><a href="#type-parameters">Type parameters</a><ul>
                            <li><a href="#bounded-type-parameters">Bounded type parameters</a></li>
                            <li><a href="#mixed-site-variance">Mixed-site variance</a></li>
                            <li><a href="#declaration-site-variance">Declaration-site variance</a></li>
                            <li><a href="#use-site-variance">Use-site variance</a></li>
                        </ul></li>
                        <li><a href="#type-capturing">Type capturing</a></li>
                    </ul></li>
                    <li><a href="#function-types">Function types</a></li>
                    <li><a href="#array-types">Array types</a></li>
                    <li><a href="#flexible-types">Flexible types</a><ul>
                        <li><a href="#platform-types">Platform types</a></li>
                    </ul></li>
                    <li><a href="#nullable-types">Nullable types</a></li>
                </ul></li>
                <li><a href="#subtyping">Subtyping</a><ul>
                    <li><a href="#subtyping-rules">Subtyping rules</a></li>
                    <li><a href="#subtyping-for-flexible-types">Subtyping for flexible types</a></li>
                    <li><a href="#subtyping-for-nullable-types">Subtyping for nullable types</a></li>
                </ul></li>
                <li><a href="#generics">Generics</a></li>
                <li><a href="#references">References</a></li>
            </ul></li>
            <li><a href="#declarations">Declarations</a><ul>
                <li><a href="#classifier-declaration">Classifier declaration</a></li>
                <li><a href="#function-declaration">Function declaration</a><ul>
                    <li><a href="#named-and-positional-parameters">Named and positional parameters</a></li>
                    <li><a href="#variable-length-parameters">Variable length parameters</a></li>
                    <li><a href="#function-type-parameters">Function type parameters</a></li>
                    <li><a href="#extension-function-declaration">Extension function declaration</a></li>
                </ul></li>
                <li><a href="#property-declaration">Property declaration</a><ul>
                    <li><a href="#read-only-property-declaration">Read-only property declaration</a></li>
                    <li><a href="#mutable-property-declaration">Mutable property declaration</a></li>
                    <li><a href="#delegated-property-declaration">Delegated property declaration</a></li>
                    <li><a href="#local-property-declaration">Local property declaration</a></li>
                    <li><a href="#getters-and-setters">Getters and setters</a></li>
                    <li><a href="#property-initialization">Property initialization</a></li>
                </ul></li>
                <li><a href="#type-alias">Type alias</a></li>
            </ul></li>
            <li><a href="#statements">Statements</a><ul>
                <li><a href="#assignments">Assignments</a><ul>
                    <li><a href="#simple-assignment">Simple assignment</a></li>
                    <li><a href="#operator-assignments">Operator assignments</a></li>
                </ul></li>
                <li><a href="#loop-statements">Loop statements</a><ul>
                    <li><a href="#while-loop">While loop</a></li>
                    <li><a href="#do-while-loop">Do-while loop</a></li>
                    <li><a href="#for-loop">For loop</a></li>
                </ul></li>
                <li><a href="#code-blocks">Code blocks</a></li>
                <li><a href="#todo">TODO</a></li>
            </ul></li>
            <li><a href="#expressions">Expressions</a><ul>
                <li><a href="#constant-literals">Constant literals</a><ul>
                    <li><a href="#boolean-literals">Boolean literals</a></li>
                    <li><a href="#integer-literals">Integer literals</a><ul>
                        <li><a href="#decimal-integer-literals">Decimal integer literals</a></li>
                        <li><a href="#hexadecimal-integer-literals">Hexadecimal integer literals</a></li>
                        <li><a href="#binary-integer-literals">Binary integer literals</a></li>
                    </ul></li>
                    <li><a href="#real-literals">Real literals</a></li>
                    <li><a href="#character-literals">Character literals</a></li>
                    <li><a href="#string-literals-1">String literals</a></li>
                    <li><a href="#null-literal">Null literal</a></li>
                </ul></li>
                <li><a href="#try-expression">Try-expression</a></li>
                <li><a href="#conditional-expression">Conditional expression</a></li>
                <li><a href="#when-expression">When expression</a><ul>
                    <li><a href="#exhaustive-when-expressions">Exhaustive when expressions</a></li>
                </ul></li>
                <li><a href="#logical-disjunction-expression">Logical disjunction expression</a></li>
                <li><a href="#logical-conjunction-expression">Logical conjunction expression</a></li>
                <li><a href="#equality-expressions">Equality expressions</a><ul>
                    <li><a href="#reference-equality-expressions">Reference equality expressions</a></li>
                    <li><a href="#value-equality-expressions">Value equality expressions</a></li>
                </ul></li>
                <li><a href="#comparison-expressions">Comparison expressions</a></li>
                <li><a href="#type-checking-and-containment-checking-expressions">Type-checking and containment-checking expressions</a><ul>
                    <li><a href="#type-checking-expression">Type-checking expression</a><ul>
                        <li><a href="#todo-1">TODO()</a></li>
                    </ul></li>
                    <li><a href="#containment-checking-expression">Containment-checking expression</a></li>
                </ul></li>
                <li><a href="#elvis-operator-expression">Elvis operator expression</a></li>
                <li><a href="#range-expression">Range expression</a></li>
                <li><a href="#additive-expression">Additive expression</a></li>
                <li><a href="#multiplicative-expression">Multiplicative expression</a></li>
                <li><a href="#cast-expression">Cast expression</a><ul>
                    <li><a href="#todo-2">TODO()</a></li>
                </ul></li>
                <li><a href="#prefix-expressions">Prefix expressions</a><ul>
                    <li><a href="#annotated-and-labeled-expression">Annotated and labeled expression</a></li>
                    <li><a href="#prefix-increment-expression">Prefix increment expression</a></li>
                    <li><a href="#prefix-decrement-expression">Prefix decrement expression</a></li>
                    <li><a href="#unary-minus-expression">Unary minus expression</a></li>
                    <li><a href="#unary-plus-expression">Unary plus expression</a></li>
                    <li><a href="#logical-not-expression">Logical not expression</a></li>
                </ul></li>
                <li><a href="#postfix-operator-expressions">Postfix operator expressions</a><ul>
                    <li><a href="#postfix-increment-expression">Postfix increment expression</a></li>
                    <li><a href="#postfix-decrement-expression">Postfix decrement expression</a></li>
                </ul></li>
                <li><a href="#not-null-assertion-expression">Not-null assertion expression</a></li>
                <li><a href="#indexing-expressions">Indexing expressions</a></li>
                <li><a href="#call-and-property-access-expressions">Call and property access expressions</a><ul>
                    <li><a href="#the-navigation-operators">The navigation operators</a></li>
                </ul></li>
                <li><a href="#function-literals">Function Literals</a><ul>
                    <li><a href="#anonymous-function-declarations">Anonymous function declarations</a></li>
                    <li><a href="#lambda-literals">Lambda literals</a></li>
                </ul></li>
                <li><a href="#object-literals">Object literals</a></li>
                <li><a href="#this-expressions">This-expressions</a></li>
                <li><a href="#super-forms">Super-forms</a></li>
                <li><a href="#jump-expressions">Jump expressions</a><ul>
                    <li><a href="#throw-expressions">Throw expressions</a></li>
                    <li><a href="#return-expressions">Return expressions</a></li>
                    <li><a href="#continue-expression">Continue expression</a></li>
                    <li><a href="#break-expression">Break expression</a></li>
                </ul></li>
                <li><a href="#operator-expressions">Operator expressions</a><ul>
                    <li><a href="#spread-operator">Spread operator</a></li>
                </ul></li>
                <li><a href="#safe-call-expression">Safe call expression</a></li>
                <li><a href="#type-check-expression">Type check expression</a></li>
            </ul></li>
            <li><a href="#todos">TODOS()</a></li>
            <li><a href="#order-of-evaluation">Order of evaluation</a></li>
            <li><a href="#semantics">Semantics</a><ul>
                <li><a href="#smart-casts">Smart casts</a></li>
            </ul></li>
            <li><a href="#control--and-data-flow-analysis">Control- and data-flow analysis</a></li>
            <li><a href="#type-inference">Type inference</a></li>
            <li><a href="#overload-resolution">Overload resolution</a><ul>
                <li><a href="#intro">Intro</a></li>
                <li><a href="#receivers">Receivers</a></li>
                <li><a href="#the-forms-of-call-expression">The forms of call-expression</a></li>
                <li><a href="#callables-and-invoke-convention">Callables and invoke convention</a></li>
                <li><a href="#overload-resolution-for-a-fully-qualified-call">Overload resolution for a fully-qualified call</a></li>
                <li><a href="#a-call-with-an-explicit-receiver">A call with an explicit receiver</a></li>
                <li><a href="#infix-function-calls">Infix function calls</a></li>
                <li><a href="#operator-calls">Operator calls</a></li>
                <li><a href="#a-call-without-an-explicit-receiver">A call without an explicit receiver</a></li>
                <li><a href="#calls-with-named-parameters">Calls with named parameters</a></li>
                <li><a href="#calls-with-trailing-lambda-expressions">Calls with trailing lambda expressions</a></li>
                <li><a href="#choosing-the-most-specific-function-from-the-overload-candidate-set">Choosing the most specific function from the overload candidate set</a><ul>
                    <li><a href="#rationale">Rationale</a></li>
                    <li><a href="#formal-definition">Formal definition(?)</a></li>
                </ul></li>
                <li><a href="#about-type-inference">About type inference</a><ul>
                    <li><a href="#todo-3">TODO:</a></li>
                </ul></li>
            </ul></li>
            <li><a href="#concurrency">Concurrency</a></li>
            <li><a href="#coroutines">Coroutines</a></li>
            <li><a href="#annotations">Annotations</a></li>
            <li><a href="#documentation-comments">Documentation comments</a></li>
            <li><a href="#fubar">FUBAR</a></li>
        </ul></li>
    </ul>
</nav>
<h1 id="glossary">Glossary</h1>
<div class="paragraph">
    <p><span class="sentence">w.r.t.:: with respect to</span></p>
</div>
<h1 id="kotlincore">Kotlin/Core</h1>
<h2 id="introduction">Introduction</h2>
<div class="paragraph">
    <p><span class="sentence">Here be dragonsâ€¦</span></p>
</div>
<h2 id="syntax">Syntax</h2>
<h3 id="grammar">Grammar</h3>
<h4 id="lexical-grammar">Lexical grammar</h4>
<h5 id="character-classes">Character classes</h5>
<dl>
    <dt><strong><em>LF</em>:</strong></dt>
    <dd><span class="sentence"><em>&lt;unicode character Line Feed U+000A&gt;</em></span>
    </dd>
    <dt><strong><em>CR</em>:</strong></dt>
    <dd><span class="sentence"><em>&lt;unicode character Carriage Return U+000D&gt;</em></span>
    </dd>
    <dt><strong><em>WS</em>:</strong></dt>
    <dd><span class="sentence"><em>&lt;one of the following characters: SPACE U+0020, TAB U+0009, Form Feed U+000C&gt;</em></span>
    </dd>
    <dt><strong><em>Underscore</em>:</strong></dt>
    <dd><span class="sentence"><em>&lt;unicode character Low Line U+005F&gt;</em></span>
    </dd>
    <dt><strong><em>Letter</em>:</strong></dt>
    <dd><span class="sentence"><em>&lt;any unicode character from classes Ll, Lm, Lo, Lt, Lu or Nl&gt;</em></span>
    </dd>
    <dt><strong><em>UnicodeDigit</em>:</strong></dt>
    <dd><span class="sentence"><em>&lt;any unicode character from class Nd&gt;</em></span>
    </dd>
    <dt><strong><em>LineCharacter</em>:</strong></dt>
    <dd><span class="sentence"><em>&lt;any unicode character excluding LF and CR&gt;</em></span>
    </dd>
    <dt><strong><em>BinaryDigit</em>:</strong></dt>
    <dd><span class="sentence"><code>0</code> | <code>1</code></span>
    </dd>
    <dt><strong><em>DecimalDigit</em>:</strong></dt>
    <dd><span class="sentence"><code>0</code> | <code>1</code> | <code>2</code> | <code>3</code> | <code>4</code> | <code>5</code> | <code>6</code> | <code>7</code> | <code>8</code> | <code>9</code></span>
    </dd>
    <dt><strong><em>HexDigit</em>:</strong></dt>
    <dd><span class="sentence"><em>DecimalDigit</em><br />
| <code>A</code> | <code>B</code> | <code>C</code> | <code>D</code> | <code>E</code> | <code>F</code><br />
| <code>a</code> | <code>b</code> | <code>c</code> | <code>d</code> | <code>e</code> | <code>f</code></span>
    </dd>
</dl>
<h3 id="keywords-and-operators">Keywords and operators</h3>
<dl>
    <dt><strong><em>Operator</em>:</strong></dt>
    <dd><span class="sentence"><code>.</code> | <code>,</code> | <code>(</code> | <code>)</code> | <code>[</code> | <code>]</code> | <code>@[</code> | <code>{</code> | <code>}</code> | <code>*</code> | <code>%</code> | <code>/</code> | <code>+</code> | <code>-</code> | <code>++</code> | <code>--</code><br />
| <code>&amp;&amp;</code> | <code>||</code> | <code>!</code> | <code>!!</code> | <code>:</code> | <code>;</code> | <code>=</code> | <code>+=</code> | <code>-=</code> | <code>*=</code> | <code>/=</code> | <code>%=</code> | <code>-&gt;</code> | <code>=&gt;</code><br />
| <code>..</code> | <code>::</code> | <code>?::</code> | <code>;;</code> | <code>#</code> | <code>@</code> | <code>?</code> | <code>?:</code> | <code>&lt;</code> | <code>&gt;</code> | <code>\m</code> | <code>&gt;=</code> | <code>!=</code> | <code>!==</code><br />
| <code>==</code> | <code>===</code> | <code>'</code> | <code>&quot;</code> | <code>&quot;&quot;&quot;</code></span>
    </dd>
    <dt><strong><em>SoftKeyword</em>:</strong></dt>
    <dd><span class="sentence"><code>public</code> | <code>private</code> | <code>protected</code> | <code>internal</code><br />
| <code>enum</code> | <code>sealed</code> | <code>annotation</code> | <code>data</code> | <code>inner</code><br />
| <code>tailrec</code> | <code>operator</code> | <code>inline</code> | <code>infix</code> | <code>external</code><br />
| <code>suspend</code> | <code>override</code> | <code>abstract</code> | <code>final</code> | <code>open</code><br />
| <code>const</code> | <code>lateinit</code> | <code>vararg</code> | <code>noinline</code> | <code>crossinline</code><br />
| <code>reified</code> | <code>expect</code> | <code>actual</code></span>
    </dd>
    <dt><strong><em>Keyword</em>:</strong></dt>
    <dd><span class="sentence"><code>package</code> | <code>import</code> | <code>class</code> | <code>interface</code><br />
| <code>fun</code> | <code>object</code> | <code>val</code> | <code>var</code> | <code>typealias</code><br />
| <code>constructor</code> | <code>by</code> | <code>companion</code> | <code>init</code><br />
| <code>this</code> | <code>super</code> | <code>typeof</code> | <code>where</code><br />
| <code>if</code> | <code>else</code> | <code>when</code> | <code>try</code> | <code>catch</code><br />
| <code>finally</code> | <code>for</code> | <code>do</code> | <code>while</code> | <code>throw</code><br />
| <code>return</code> | <code>continue</code> | <code>break</code> | <code>as</code><br />
| <code>is</code> | <code>in</code> | <code>!is</code> | <code>!in</code> | <code>out</code><br />
| <code>get</code> | <code>set</code> | <code>dynamic</code> | <code>@file</code><br />
| <code>@field</code> | <code>@property</code> | <code>@get</code> | <code>@set</code><br />
| <code>@receiver</code> | <code>@param</code> | <code>@setparam</code> | <code>@delegate</code></span>
    </dd>
</dl>
<h5 id="whitespace-and-comments">Whitespace and comments</h5>
<dl>
    <dt><strong><em>NL</em>:</strong></dt>
    <dd><span class="sentence"><em>LF</em> | <em>CR</em> [<em>LF</em>]</span>
    </dd>
    <dt><strong><em>ShebangLine</em>:</strong></dt>
    <dd><span class="sentence"><code>#!</code> {<em>LineCharacter</em>}</span>
    </dd>
    <dt><strong><em>LineComment</em>:</strong></dt>
    <dd><span class="sentence"><code>//</code> {<em>LineCharacter</em>}</span>
    </dd>
    <dt><strong><em>DelimitedComment</em>:</strong></dt>
    <dd><span class="sentence"><code>/*</code> {<em>DelimitedComment</em> | &lt;any character&gt;} <code>*/</code></span>
    </dd>
</dl>
<h5 id="number-literals">Number literals</h5>
<dl>
    <dt><strong><em>RealLiteral</em>:</strong></dt>
    <dd><span class="sentence"><em>FloatLiteral</em> | <em>DoubleLiteral</em></span>
    </dd>
    <dt><strong><em>FloatLiteral</em>:</strong></dt>
    <dd><span class="sentence"><em>DoubleLiteral</em> (<code>f</code> | <code>F</code>) | <em>DecDigits</em> (<code>f</code> | <code>F</code>)</span>
    </dd>
    <dt><strong><em>DoubleLiteral</em>:</strong></dt>
    <dd><span class="sentence">[<em>DecDigits</em>] <code>.</code> <em>DecDigits</em> [<em>DoubleExponent</em>] | <em>DecDigits</em> <em>DoubleExponent</em></span>
    </dd>
    <dt><strong><em>LongLiteral</em>:</strong></dt>
    <dd><span class="sentence">(<em>IntegerLiteral</em> | <em>HexLiteral</em> | <em>BinLiteral</em>) <code>L</code></span>
    </dd>
    <dt><strong><em>IntegerLiteral</em>:</strong></dt>
    <dd><span class="sentence"><em>DecDigitNoZero</em> {<em>DecDigitOrSeparator</em>} <em>DecDigit</em> | <em>DecDigit</em></span>
    </dd>
    <dt><strong><em>HexLiteral</em>:</strong></dt>
    <dd><span class="sentence"><code>0</code> (<code>x</code>|<code>X</code>) <em>HexDigit</em> {<em>HexDigitOrSeparator</em>} <em>HexDigit</em><br />
| <code>0</code> (<code>x</code>|<code>X</code>) <em>HexDigit</em></span>
    </dd>
    <dt><strong><em>BinLiteral</em>:</strong></dt>
    <dd><span class="sentence"><code>0</code> (<code>b</code>|<code>B</code>) <em>BinDigit</em> {<em>BinDigitOrSeparator</em>} <em>BinDigit</em><br />
| <code>0</code> (<code>b</code>|<code>B</code>) <em>BinDigit</em></span>
    </dd>
    <dt><strong><em>DecDigitNoZero</em>:</strong></dt>
    <dd><span class="sentence"><em>DecDigit</em> - <code>0</code></span>
    </dd>
    <dt><strong><em>DecDigitOrSeparator</em>:</strong></dt>
    <dd><span class="sentence"><em>DecDigit</em> | <em>Underscore</em></span>
    </dd>
    <dt><strong><em>HexDigitOrSeparator</em>:</strong></dt>
    <dd><span class="sentence"><em>HexDigit</em> | <em>Underscore</em></span>
    </dd>
    <dt><strong><em>BinDigitOrSeparator</em>:</strong></dt>
    <dd><span class="sentence"><em>BinDigit</em> | <em>Underscore</em></span>
    </dd>
    <dt><strong><em>DecDigits</em>:</strong></dt>
    <dd><span class="sentence"><em>DecDigit</em> {<em>DecDigitOrSeparator</em>} <em>DecDigit</em> | <em>DecDigit</em></span>
    </dd>
    <dt><strong><em>BooleanLiteral</em>:</strong></dt>
    <dd><span class="sentence"><code>true</code> | <code>false</code></span>
    </dd>
    <dt><strong><em>NullLiteral</em>:</strong></dt>
    <dd><span class="sentence"><code>null</code></span>
    </dd>
</dl>
<h5 id="identifiers">Identifiers</h5>
<dl>
    <dt><strong><em>Identifier</em>:</strong></dt>
    <dd><span class="sentence">(<em>Letter</em> | <em>Underscore</em>) {<em>Letter</em> | <em>Underscore</em> | <em>UnicodeDigit</em>}<br />
| <code>`</code> {<em>EscapedIdentifierCharacter</em>} <code>`</code></span>
    </dd>
    <dt><strong><em>EscapedIdentifierCharacter</em>:</strong></dt>
    <dd><span class="sentence"><em>&lt;any character except CR, LF, <code>`</code>, <code>[</code>, <code>]</code>, <code>&lt;</code> or <code>&gt;</code>&gt;</em></span>
    </dd>
    <dt><strong><em>IdentifierOrSoftKey</em>:</strong></dt>
    <dd><span class="sentence"><em>Identifier</em> | <em>SoftKeyword</em></span>
    </dd>
    <dt><strong><em>AtIdentifier</em>:</strong></dt>
    <dd><span class="sentence"><code>@</code> <em>IdentifierOrSoftKey</em></span>
    </dd>
    <dt><strong><em>IdentifierAt</em>:</strong></dt>
    <dd><span class="sentence"><em>IdentifierOrSoftKey</em> <code>@</code></span>
    </dd>
</dl>
<h5 id="string-literals">String literals</h5>
<div class="paragraph">
    <p><span class="sentence">Syntax literals are fully defined in syntax grammar due to the complex nature of string interpolation</span></p>
</div>
<dl>
    <dt><strong><em>CharacterLiteral</em>:</strong></dt>
    <dd><span class="sentence"><code>'</code> (<em>EscapeSeq</em> | <em>&lt;any character except CR, LF, <code>'</code> and <code>\</code>&gt;</em>) <code>'</code></span>
    </dd>
    <dt><strong><em>EscapeSeq</em>:</strong></dt>
    <dd><span class="sentence"><em>UnicodeCharacterLiteral</em> | <em>EscapedCharacter</em></span>
    </dd>
    <dt><strong><em>UnicodeCharacterLiteral</em>:</strong></dt>
    <dd><span class="sentence"><code>\</code> <code>u</code> <em>HexDigit</em> <em>HexDigit</em> <em>HexDigit</em> <em>HexDigit</em></span>
    </dd>
    <dt><strong><em>EscapedCharacter</em>:</strong></dt>
    <dd><span class="sentence"><code>\</code> (<code>t</code> | <code>b</code> | <code>r</code> | <code>n</code> | <code>'</code> | <code>&quot;</code> | <code>\</code> | <code>$</code>)</span>
    </dd>
    <dt><strong><em>FieldIdentifier</em>:</strong></dt>
    <dd><span class="sentence"><code>$</code> <em>IdentifierOrSoftKey</em></span>
    </dd>
    <dt><strong><em>LineStrRef</em>:</strong></dt>
    <dd><span class="sentence"><em>FieldIdentifier</em></span>
    </dd>
    <dt><strong><em>LineStrEscapedChar</em>:</strong></dt>
    <dd><span class="sentence"><em>EscapedCharacter</em> | <em>UnicodeCharacterLiteral</em></span>
    </dd>
    <dt><strong><em>LineStrExprStart</em>:</strong></dt>
    <dd><span class="sentence"><code>${</code></span>
    </dd>
    <dt><strong><em>MultiLineStringQuote</em>:</strong></dt>
    <dd><span class="sentence"><code>&quot;</code> {<code>&quot;</code>}</span>
    </dd>
    <dt><strong><em>MultiLineStrRef</em>:</strong></dt>
    <dd><span class="sentence"><em>FieldIdentifier</em></span>
    </dd>
    <dt><strong><em>MultiLineStrText</em>:</strong></dt>
    <dd><span class="sentence">{&lt;any character except <code>&quot;</code> and <code>$</code>} | <code>$</code></span>
    </dd>
    <dt><strong><em>MultiLineStrExprStart</em>:</strong></dt>
    <dd><span class="sentence"><code>${</code></span>
    </dd>
</dl>
<h4 id="syntax-grammar">Syntax grammar</h4>
<dl>
    <dt><strong><em>kotlinFile</em>:</strong></dt>
    <dd><span class="sentence">[<em>shebangLine</em>] {<em>NL</em>} {<em>fileAnnotation</em>} <em>packageHeader</em> <em>importList</em> {<em>topLevelObject</em>} <em>EOF</em></span>
    </dd>
    <dt><strong><em>script</em>:</strong></dt>
    <dd><span class="sentence">[<em>shebangLine</em>] {<em>NL</em>} {<em>fileAnnotation</em>} <em>packageHeader</em> <em>importList</em> {statement <em>semi</em>} <em>EOF</em></span>
    </dd>
    <dt><strong><em>fileAnnotation</em>:</strong></dt>
    <dd><span class="sentence"><code>@file</code> <code>:</code> (<code>[</code> <em>unescapedAnnotation</em>+ <code>]</code> | <em>unescapedAnnotation</em>) <em>semi</em></span>
    </dd>
    <dt><strong><em>packageHeader</em>:</strong></dt>
    <dd><span class="sentence">[<code>package</code> <em>identifier</em> <em>semi</em>]</span>
    </dd>
    <dt><strong><em>importList</em>:</strong></dt>
    <dd><span class="sentence">{<em>importHeader</em>}</span>
    </dd>
    <dt><strong><em>importHeader</em>:</strong></dt>
    <dd><span class="sentence"><code>import</code> <em>identifier</em> [<code>.</code> <code>*</code> | <em>importAlias</em>] <em>semi</em></span>
    </dd>
    <dt><strong><em>importAlias</em>:</strong></dt>
    <dd><span class="sentence"><code>as</code> <em>simpleIdentifier</em></span>
    </dd>
    <dt><strong><em>topLevelObject</em>:</strong></dt>
    <dd><span class="sentence"><em>declaration</em> <em>semis</em></span>
    </dd>
    <dt><strong><em>classDeclaration</em>:</strong></dt>
    <dd><span class="sentence">[<em>modifierList</em>] (<code>class</code> | <code>interface</code>) {<em>NL</em>} <em>simpleIdentifier</em><br />
[{<em>NL</em>} <em>typeParameters</em>] [{<em>NL</em>} <em>primaryConstructor</em>]<br />
[{<em>NL</em>} <code>:</code> {<em>NL</em>} <em>delegationSpecifiers</em>]<br />
[{<em>NL</em>} <em>typeConstraints</em>]<br />
[{<em>NL</em>} <em>classBody</em> | {<em>NL</em>} <em>enumClassBody</em>]</span>
    </dd>
    <dt><strong><em>primaryConstructor</em>:</strong></dt>
    <dd><span class="sentence">[<em>modifierList</em>] [<code>constructor</code> {<em>NL</em>}] <em>classParameters</em></span>
    </dd>
    <dt><strong><em>classParameters</em>:</strong></dt>
    <dd><span class="sentence"><code>(</code> {<em>NL</em>} [<em>classParameter</em> {{<em>NL</em>} <code>,</code> {<em>NL</em>} <em>classParameter</em>}] {<em>NL</em>} <code>)</code></span>
    </dd>
    <dt><strong><em>classParameter</em>:</strong></dt>
    <dd><span class="sentence">[<em>modifierList</em>] [<code>val</code> | <code>var</code>] {<em>NL</em>} <em>simpleIdentifier</em> <code>:</code> {<em>NL</em>} <em>type</em> [{<em>NL</em>} <code>=</code> {<em>NL</em>} <em>expression</em>]</span>
    </dd>
    <dt><strong><em>delegationSpecifiers</em>:</strong></dt>
    <dd><span class="sentence"><em>annotatedDelegationSpecifier</em> {{<em>NL</em>} <code>,</code> {<em>NL</em>} <em>annotatedDelegationSpecifier</em>}</span>
    </dd>
    <dt><strong><em>annotatedDelegationSpecifier</em>:</strong></dt>
    <dd><span class="sentence">{<em>annotation</em>} {<em>NL</em>} <em>delegationSpecifier</em></span>
    </dd>
    <dt><strong><em>delegationSpecifier</em>:</strong></dt>
    <dd><span class="sentence"><em>constructorInvocation</em><br />
| <em>userType</em><br />
| <em>functionType</em><br />
| <em>explicitDelegation</em></span>
    </dd>
    <dt><strong><em>constructorInvocation</em>:</strong></dt>
    <dd><span class="sentence"><em>userType</em> <em>callSuffix</em></span>
    </dd>
    <dt><strong><em>explicitDelegation</em>:</strong></dt>
    <dd><span class="sentence">(<em>userType</em> | <em>functionType</em>) {<em>NL</em>} <code>by</code> {<em>NL</em>} <em>expression</em></span>
    </dd>
    <dt><strong><em>classBody</em>:</strong></dt>
    <dd><span class="sentence"><code>{</code> {<em>NL</em>} [<em>classMemberDeclarations</em>] {<em>NL</em>} <code>}</code></span>
    </dd>
    <dt><strong><em>classMemberDeclarations</em>:</strong></dt>
    <dd><span class="sentence">{<em>classMemberDeclaration</em> <em>semis</em>} <em>classMemberDeclaration</em> [<em>semis</em>]</span>
    </dd>
    <dt><strong><em>classMemberDeclaration</em>:</strong></dt>
    <dd><span class="sentence"><em>declaration</em><br />
| <em>companionObject</em><br />
| <em>anonymousInitializer</em><br />
| <em>secondaryConstructor</em></span>
    </dd>
    <dt><strong><em>anonymousInitializer</em>:</strong></dt>
    <dd><span class="sentence"><code>init</code> {<em>NL</em>} <em>block</em></span>
    </dd>
    <dt><strong><em>secondaryConstructor</em>:</strong></dt>
    <dd><span class="sentence">[<em>modifierList</em>] <code>constructor</code> {<em>NL</em>} <em>functionValueParameters</em> [{<em>NL</em>} <code>:</code> {<em>NL</em>} <em>constructorDelegationCall</em>] {<em>NL</em>} [<em>block</em>]</span>
    </dd>
    <dt><strong><em>constructorDelegationCall</em>:</strong></dt>
    <dd><span class="sentence"><code>this</code> {<em>NL</em>} <em>valueArguments</em><br />
| <code>super</code> {<em>NL</em>} <em>valueArguments</em></span>
    </dd>
    <dt><strong><em>enumClassBody</em>:</strong></dt>
    <dd><span class="sentence"><code>{</code> {<em>NL</em>} [<em>enumEntries</em>] [{<em>NL</em>} <code>;</code> {<em>NL</em>} [<em>classMemberDeclarations</em>]] {<em>NL</em>} <code>}</code></span>
    </dd>
    <dt><strong><em>enumEntries</em>:</strong></dt>
    <dd><span class="sentence"><em>enumEntry</em> {{<em>NL</em>} <code>,</code> {<em>NL</em>} <em>enumEntry</em>} {<em>NL</em>} [<code>,</code>]</span>
    </dd>
    <dt><strong><em>enumEntry</em>:</strong></dt>
    <dd><span class="sentence">[modifierList {<em>NL</em>}] <em>simpleIdentifier</em> [{<em>NL</em>} <em>valueArguments</em>] [{<em>NL</em>} <em>classBody</em>]</span>
    </dd>
    <dt><strong><em>functionDeclaration</em>:</strong></dt>
    <dd><span class="sentence">[<em>modifierList</em>]<br />
<code>fun</code><br />
[{<em>NL</em>} <em>typeParameters</em>]<br />
[{<em>NL</em>} <em>type</em> {<em>NL</em>} <code>.</code>] ({<em>NL</em>} <em>simpleIdentifier</em>)<br />
{<em>NL</em>} <em>functionValueParameters</em><br />
[{<em>NL</em>} <code>:</code> {<em>NL</em>} <em>type</em>]<br />
[{<em>NL</em>} <em>typeConstraints</em>]<br />
[{<em>NL</em>} <em>functionBody</em>]</span>
    </dd>
    <dt><strong><em>functionValueParameters</em>:</strong></dt>
    <dd><span class="sentence"><code>(</code> {<em>NL</em>} [<em>functionValueParameter</em> {{<em>NL</em>} <code>,</code> {<em>NL</em>} <em>functionValueParameter</em>}] {<em>NL</em>} <code>)</code></span>
    </dd>
    <dt><strong><em>functionValueParameter</em>:</strong></dt>
    <dd><span class="sentence">[<em>modifierList</em>] <em>parameter</em> [{<em>NL</em>} <code>=</code> {<em>NL</em>} <em>expression</em>]</span>
    </dd>
    <dt><strong><em>parameter</em>:</strong></dt>
    <dd><span class="sentence"><em>simpleIdentifier</em> {<em>NL</em>} [<code>:</code> {<em>NL</em>} <em>type</em>]</span>
    </dd>
    <dt><strong><em>functionBody</em>:</strong></dt>
    <dd><span class="sentence"><em>block</em><br />
| <code>=</code> {<em>NL</em>} <em>expression</em></span>
    </dd>
    <dt><strong><em>objectDeclaration</em>:</strong></dt>
    <dd><span class="sentence">[<em>modifierList</em>] <code>object</code><br />
{<em>NL</em>} <em>simpleIdentifier</em><br />
[{<em>NL</em>} <code>:</code> {<em>NL</em>} <em>delegationSpecifiers</em>]<br />
[{<em>NL</em>} <em>classBody</em>]</span>
    </dd>
    <dt><strong><em>companionObject</em>:</strong></dt>
    <dd><span class="sentence">[<em>modifierList</em>] <code>companion</code> {<em>NL</em>} <code>object</code><br />
[{<em>NL</em>} <em>simpleIdentifier</em>]<br />
[{<em>NL</em>} <code>:</code> {<em>NL</em>} <em>delegationSpecifiers</em>]<br />
[{<em>NL</em>} <em>classBody</em>]</span>
    </dd>
    <dt><strong><em>propertyDeclaration</em>:</strong></dt>
    <dd><span class="sentence">[<em>modifierList</em>] (<code>val</code> | <code>var</code>)<br />
[{<em>NL</em>} <em>typeParameters</em>]<br />
[{<em>NL</em>} <em>type</em> {<em>NL</em>} <code>.</code>]<br />
({<em>NL</em>} (<em>multiVariableDeclaration</em> | <em>variableDeclaration</em>))<br />
[{<em>NL</em>} <em>typeConstraints</em>]<br />
[{<em>NL</em>} (<code>by</code> | <code>=</code>) {<em>NL</em>} <em>expression</em>]<br />
[NL+ <code>;</code>] {<em>NL</em>} [[<em>getter</em>] ({<em>NL</em>} [<em>semi</em>] <em>setter</em>] | [<em>setter</em>] [{<em>NL</em>} [<em>semi</em>] <em>getter</em>])</span>
    </dd>
    <dt><strong><em>multiVariableDeclaration</em>:</strong></dt>
    <dd><span class="sentence"><code>(</code> {<em>NL</em>} <em>variableDeclaration</em> {{<em>NL</em>} <code>,</code> {<em>NL</em>} <em>variableDeclaration</em>} {<em>NL</em>} <code>)</code></span>
    </dd>
    <dt><strong><em>variableDeclaration</em>:</strong></dt>
    <dd><span class="sentence">{<em>annotation</em>} {<em>NL</em>} <em>simpleIdentifier</em> [{<em>NL</em>} <code>:</code> {<em>NL</em>} <em>type</em>]</span>
    </dd>
    <dt><strong><em>getter</em>:</strong></dt>
    <dd><span class="sentence">[<em>modifierList</em>] <code>get</code><br />
| [<em>modifierList</em>] <code>get</code> {<em>NL</em>} <code>(</code> {<em>NL</em>} <code>)</code> [{<em>NL</em>} <code>:</code> {<em>NL</em>} <em>type</em>] {<em>NL</em>} <em>functionBody</em></span>
    </dd>
    <dt><strong><em>setter</em>:</strong></dt>
    <dd><span class="sentence">[<em>modifierList</em>] <code>set</code><br />
| [<em>modifierList</em>] <code>set</code> {<em>NL</em>} <code>(</code> {annotation | <em>parameterModifier</em>} <em>parameter</em> <code>)</code> [{<em>NL</em>} <code>:</code> {<em>NL</em>} <em>type</em>] {<em>NL</em>} <em>functionBody</em></span>
    </dd>
    <dt><strong><em>typeAlias</em>:</strong></dt>
    <dd><span class="sentence">[<em>modifierList</em>] <code>typealias</code> {<em>NL</em>} <em>simpleIdentifier</em> [{<em>NL</em>} <em>typeParameters</em>] {<em>NL</em>} <code>=</code> {<em>NL</em>} <em>type</em></span>
    </dd>
    <dt><strong><em>typeParameters</em>:</strong></dt>
    <dd><span class="sentence"><code>&lt;</code> {<em>NL</em>} <em>typeParameter</em> {{<em>NL</em>} <code>,</code> {<em>NL</em>} <em>typeParameter</em>} {<em>NL</em>} <code>&gt;</code></span>
    </dd>
    <dt><strong><em>typeParameter</em>:</strong></dt>
    <dd><span class="sentence">[<em>modifierList</em>] {<em>NL</em>} <em>simpleIdentifier</em> [{<em>NL</em>} <code>:</code> {<em>NL</em>} <em>type</em>]</span>
    </dd>
    <dt><strong><em>type</em>:</strong></dt>
    <dd><span class="sentence">[<em>typeModifierList</em>]<br />
( <em>parenthesizedType</em><br />
| <em>nullableType</em><br />
| <em>typeReference</em><br />
| <em>functionType</em>)</span>
    </dd>
    <dt><strong><em>typeModifierList</em>:</strong></dt>
    <dd><span class="sentence">(<em>annotation</em> | <code>suspend</code> {<em>NL</em>} {<em>annotation</em> | <code>suspend</code> {<em>NL</em>}})</span>
    </dd>
    <dt><strong><em>parenthesizedType</em>:</strong></dt>
    <dd><span class="sentence"><code>(</code> <em>type</em> <code>)</code></span>
    </dd>
    <dt><strong><em>nullableType</em>:</strong></dt>
    <dd><span class="sentence">(<em>typeReference</em> | <em>parenthesizedType</em>) {<em>NL</em>} <code>?</code>+</span>
    </dd>
    <dt><strong><em>typeReference</em>:</strong></dt>
    <dd><span class="sentence"><code>(</code> <em>typeReference</em> <code>)</code><br />
| <em>userType</em><br />
| <code>dynamic</code></span>
    </dd>
    <dt><strong><em>functionType</em>:</strong></dt>
    <dd><span class="sentence">[<em>receiverType</em> {<em>NL</em>} <code>.</code> {<em>NL</em>}] <em>functionTypeParameters</em> {<em>NL</em>} <code>-&gt;</code> [{<em>NL</em>} <em>type</em>]</span>
    </dd>
    <dt><strong><em>receiverType</em>:</strong></dt>
    <dd><span class="sentence"><em>parenthesizedType</em><br />
| <em>nullableType</em><br />
| <em>typeReference</em></span>
    </dd>
    <dt><strong><em>userType</em>:</strong></dt>
    <dd><span class="sentence"><em>simpleUserType</em> {{<em>NL</em>} <code>.</code> {<em>NL</em>} <em>simpleUserType</em>}</span>
    </dd>
    <dt><strong><em>simpleUserType</em>:</strong></dt>
    <dd><span class="sentence"><em>simpleIdentifier</em> [{<em>NL</em>} <em>typeArguments</em>]</span>
    </dd>
    <dt><strong><em>functionTypeParameters</em>:</strong></dt>
    <dd><span class="sentence"><code>[</code> {<em>NL</em>} (<em>parameter</em> | <em>type</em>) {{<em>NL</em>} <code>,</code> {<em>NL</em>} (<em>parameter</em> | <em>type</em>)} {<em>NL</em>} <code>)</code></span>
    </dd>
    <dt><strong><em>typeConstraints</em>:</strong></dt>
    <dd><span class="sentence"><code>where</code> {<em>NL</em>} <em>typeConstraint</em> {{<em>NL</em>} <code>,</code> {<em>NL</em>} <em>typeConstraint</em>}</span>
    </dd>
    <dt><strong><em>typeConstraint</em>:</strong></dt>
    <dd><span class="sentence">{<em>annotation</em>} <em>simpleIdentifier</em> {<em>NL</em>} <code>:</code> {<em>NL</em>} <em>type</em></span>
    </dd>
    <dt><strong><em>block</em>:</strong></dt>
    <dd><span class="sentence"><code>{</code> {<em>NL</em>} <em>statements</em> {<em>NL</em>} <code>}</code></span>
    </dd>
    <dt><strong><em>statements</em>:</strong></dt>
    <dd><span class="sentence">[<em>statement</em> {semis <em>statement</em>} [<em>semis</em>]]</span>
    </dd>
    <dt><strong><em>statement</em>:</strong></dt>
    <dd><span class="sentence">{<em>labelDefinition</em>}<br />
( <em>declaration</em><br />
| <em>assignment</em><br />
| <em>loopStatement</em><br />
| <em>expression</em>)</span>
    </dd>
    <dt><strong><em>declaration</em>:</strong></dt>
    <dd><span class="sentence"><em>classDeclaration</em><br />
| <em>objectDeclaration</em><br />
| <em>functionDeclaration</em><br />
| <em>propertyDeclaration</em><br />
| <em>typeAlias</em></span>
    </dd>
    <dt><strong><em>assignment</em>:</strong></dt>
    <dd><span class="sentence"><em>directlyAssignableExpression</em> <code>=</code> {<em>NL</em>} <em>expression</em><br />
| <em>assignableExpression</em> <em>assignmentAndOperator</em> {<em>NL</em>} <em>expression</em></span>
    </dd>
    <dt><strong><em>expression</em>:</strong></dt>
    <dd><span class="sentence"><em>disjunction</em> | <em>ifExpression</em></span>
    </dd>
    <dt><strong><em>ifExpression</em>:</strong></dt>
    <dd><span class="sentence"><code>if</code> {<em>NL</em>} <code>(</code> {<em>NL</em>} <em>expression</em> {<em>NL</em>} <code>)</code> {<em>NL</em>} <em>controlStructureBody</em> [[<code>;</code>] {<em>NL</em>} <code>else</code> {<em>NL</em>} <em>controlStructureBody</em>]<br />
| <code>if</code> {<em>NL</em>} <code>(</code> {<em>NL</em>} <em>expression</em> {<em>NL</em>} <code>)</code> {<em>NL</em>} [<code>;</code> {<em>NL</em>}] <code>else</code> {<em>NL</em>} <em>controlStructureBody</em></span>
    </dd>
    <dt><strong><em>disjunction</em>:</strong></dt>
    <dd><span class="sentence"><em>conjunction</em> {{<em>NL</em>} <code>||</code> {<em>NL</em>} (<em>conjunction</em> | <em>ifExpression</em>)}</span>
    </dd>
    <dt><strong><em>conjunction</em>:</strong></dt>
    <dd><span class="sentence"><em>equality</em> {{<em>NL</em>} <code>&amp;&amp;</code> {<em>NL</em>} (<em>equality</em> | <em>ifExpression</em>)}</span>
    </dd>
    <dt><strong><em>equality</em>:</strong></dt>
    <dd><span class="sentence"><em>comparison</em> {<em>equalityOperator</em> {<em>NL</em>} (<em>comparison</em> | <em>ifExpression</em>)}</span>
    </dd>
    <dt><strong><em>comparison</em>:</strong></dt>
    <dd><span class="sentence"><em>infixOperation</em> [<em>comparisonOperator</em> {<em>NL</em>} (<em>infixOperation</em> | <em>ifExpression</em>)]</span>
    </dd>
    <dt><strong><em>infixOperation</em>:</strong></dt>
    <dd><span class="sentence"><em>elvisExpression</em> {<em>inOperator</em> {<em>NL</em>} (<em>elvisExpression</em> | <em>ifExpression</em>) | <em>isOperator</em> {<em>NL</em>} <em>type</em>}</span>
    </dd>
    <dt><strong><em>elvisExpression</em>:</strong></dt>
    <dd><span class="sentence"><em>infixFunctionCall</em> {{<em>NL</em>} <code>?:</code> {<em>NL</em>} (<em>infixFunctionCall</em> | <em>ifExpression</em>)}</span>
    </dd>
    <dt><strong><em>infixFunctionCall</em>:</strong></dt>
    <dd><span class="sentence"><em>rangeExpression</em> {<em>simpleIdentifier</em> {<em>NL</em>} (<em>rangeExpression</em> | <em>ifExpression</em>)}</span>
    </dd>
    <dt><strong><em>rangeExpression</em>:</strong></dt>
    <dd><span class="sentence"><em>additiveExpression</em> {<code>..</code> {<em>NL</em>} (<em>additiveExpression</em> | <em>ifExpression</em>)}</span>
    </dd>
    <dt><strong><em>additiveExpression</em>:</strong></dt>
    <dd><span class="sentence"><em>multiplicativeExpression</em> {<em>additiveOperator</em> {<em>NL</em>} (<em>multiplicativeExpression</em> | <em>ifExpression</em>)}</span>
    </dd>
    <dt><strong><em>multiplicativeExpression</em>:</strong></dt>
    <dd><span class="sentence"><em>asExpression</em> {<em>multiplicativeOperator</em> {<em>NL</em>} (<em>asExpression</em> | <em>ifExpression</em>)}</span>
    </dd>
    <dt><strong><em>asExpression</em>:</strong></dt>
    <dd><span class="sentence"><em>prefixUnaryExpression</em> [{<em>NL</em>} <em>asOperator</em> {<em>NL</em>} <em>type</em>]</span>
    </dd>
    <dt><strong><em>prefixUnaryExpression</em>:</strong></dt>
    <dd><span class="sentence">{<em>unaryPrefix</em>} <em>postfixUnaryExpression</em><br />
| <em>unaryPrefix</em> {<em>unaryPrefix</em>} <em>ifExpression</em></span>
    </dd>
    <dt><strong><em>unaryPrefix</em>:</strong></dt>
    <dd><span class="sentence"><em>annotation</em><br />
| <em>labelDefinition</em><br />
| <em>prefixUnaryOperator</em> {<em>NL</em>}</span>
    </dd>
    <dt><strong><em>postfixUnaryExpression</em>:</strong></dt>
    <dd><span class="sentence"><em>primaryExpression</em> {<em>postfixUnarySuffix</em>}</span>
    </dd>
    <dt><strong><em>postfixUnarySuffix</em>:</strong></dt>
    <dd><span class="sentence"><em>postfixUnaryOperator</em><br />
| <em>typeArguments</em><br />
| <em>callSuffix</em><br />
| <em>indexingSuffix</em><br />
| <em>navigationSuffix</em></span>
    </dd>
    <dt><strong><em>directlyAssignableExpression</em>:</strong></dt>
    <dd><span class="sentence"><em>postfixUnaryExpression</em> <em>assignableSuffix</em><br />
| <em>simpleIdentifier</em></span>
    </dd>
    <dt><strong><em>assignableExpression</em>:</strong></dt>
    <dd><span class="sentence"><em>prefixUnaryExpression</em></span>
    </dd>
    <dt><strong><em>assignableSuffix</em>:</strong></dt>
    <dd><span class="sentence"><em>typeArguments</em><br />
| <em>indexingSuffix</em><br />
| <em>navigationSuffix</em></span>
    </dd>
    <dt><strong><em>indexingSuffix</em>:</strong></dt>
    <dd><span class="sentence"><code>[</code> {<em>NL</em>} <em>expression</em> {{<em>NL</em>} <code>,</code> {<em>NL</em>} <em>expression</em>} {<em>NL</em>} <code>]</code></span>
    </dd>
    <dt><strong><em>navigationSuffix</em>:</strong></dt>
    <dd><span class="sentence">{<em>NL</em>} <em>memberAccessOperator</em> {<em>NL</em>} (<em>simpleIdentifier</em> | <code>class</code>)</span>
    </dd>
    <dt><strong><em>callSuffix</em>:</strong></dt>
    <dd><span class="sentence">[<em>typeArguments</em>] [<em>valueArguments</em>] <em>annotatedLambda</em><br />
| [<em>typeArguments</em>] <em>valueArguments</em></span>
    </dd>
    <dt><strong><em>annotatedLambda</em>:</strong></dt>
    <dd><span class="sentence">{annotation | <em>IdentifierAt</em>} {<em>NL</em>} <em>lambdaLiteral</em></span>
    </dd>
    <dt><strong><em>valueArguments</em>:</strong></dt>
    <dd><span class="sentence"><code>(</code> {<em>NL</em>} [<em>valueArgument</em>] {<em>NL</em>} <code>)</code><br />
| <code>(</code> {<em>NL</em>} <em>valueArgument</em> {{<em>NL</em>} <code>,</code> {<em>NL</em>} <em>valueArgument</em>} {<em>NL</em>} <code>)</code></span>
    </dd>
    <dt><strong><em>typeArguments</em>:</strong></dt>
    <dd><span class="sentence"><code>&lt;</code> {<em>NL</em>} <em>typeProjection</em> {{<em>NL</em>} <code>,</code> {<em>NL</em>} <em>typeProjection</em>} {<em>NL</em>} <code>&gt;</code></span>
    </dd>
    <dt><strong><em>typeProjection</em>:</strong></dt>
    <dd><span class="sentence">[<em>typeProjectionModifierList</em>] <em>type</em> | <code>*</code></span>
    </dd>
    <dt><strong><em>typeProjectionModifierList</em>:</strong></dt>
    <dd><span class="sentence">{<em>varianceAnnotation</em>}</span>
    </dd>
    <dt><strong><em>valueArgument</em>:</strong></dt>
    <dd><span class="sentence">[<em>annotation</em>] {<em>NL</em>} [<em>simpleIdentifier</em> {<em>NL</em>} <code>=</code> {<em>NL</em>}] {<code>*</code>} {<em>NL</em>} <em>expression</em></span>
    </dd>
    <dt><strong><em>primaryExpression</em>:</strong></dt>
    <dd><span class="sentence"><em>parenthesizedExpression</em><br />
| <em>literalConstant</em><br />
| <em>stringLiteral</em><br />
| <em>simpleIdentifier</em><br />
| <em>callableReference</em><br />
| <em>functionLiteral</em><br />
| <em>objectLiteral</em><br />
| <em>collectionLiteral</em><br />
| <em>thisExpression</em><br />
| <em>superExpression</em><br />
| <em>whenExpression</em><br />
| <em>tryExpression</em><br />
| <em>jumpExpression</em></span>
    </dd>
    <dt><strong><em>parenthesizedExpression</em>:</strong></dt>
    <dd><span class="sentence"><code>(</code> {<em>NL</em>} <em>expression</em> {<em>NL</em>} <code>)</code></span>
    </dd>
    <dt><strong><em>collectionLiteral</em>:</strong></dt>
    <dd><span class="sentence"><code>[</code> {<em>NL</em>} <em>expression</em> {{<em>NL</em>} <code>,</code> {<em>NL</em>} <em>expression</em>} {<em>NL</em>} <code>]</code><br />
| <code>[</code> {<em>NL</em>} <code>]</code></span>
    </dd>
    <dt><strong><em>literalConstant</em>:</strong></dt>
    <dd><span class="sentence"><em>BooleanLiteral</em><br />
| <em>IntegerLiteral</em><br />
| <em>HexLiteral</em><br />
| <em>BinLiteral</em><br />
| <em>CharacterLiteral</em><br />
| <em>RealLiteral</em><br />
| <em>NullLiteral</em><br />
| <em>LongLiteral</em></span>
    </dd>
    <dt><strong><em>stringLiteral</em>:</strong></dt>
    <dd><span class="sentence"><em>lineStringLiteral</em><br />
| <em>multiLineStringLiteral</em></span>
    </dd>
    <dt><strong><em>lineStringLiteral</em>:</strong></dt>
    <dd><span class="sentence"><code>&quot;</code> {<em>lineStringContent</em> | <em>lineStringExpression</em>} <code>&quot;</code></span>
    </dd>
    <dt><strong><em>multiLineStringLiteral</em>:</strong></dt>
    <dd><span class="sentence"><code>&quot;&quot;&quot;</code> {<em>multiLineStringContent</em> | <em>multiLineStringExpression</em> | <em>MultiLineStringQuote</em>} <code>&quot;&quot;&quot;</code></span>
    </dd>
    <dt><strong><em>lineStringContent</em>:</strong></dt>
    <dd><span class="sentence"><em>LineStrText</em><br />
| <em>LineStrEscapedChar</em><br />
| <em>LineStrRef</em></span>
    </dd>
    <dt><strong><em>lineStringExpression</em>:</strong></dt>
    <dd><span class="sentence"><em>LineStrExprStart</em> <em>expression</em> <code>}</code></span>
    </dd>
    <dt><strong><em>multiLineStringContent</em>:</strong></dt>
    <dd><span class="sentence"><em>MultiLineStrText</em><br />
| <em>MultiLineStringQuote</em><br />
| <em>MultiLineStrRef</em></span>
    </dd>
    <dt><strong><em>multiLineStringExpression</em>:</strong></dt>
    <dd><span class="sentence"><em>MultiLineStrExprStart</em> {<em>NL</em>} <em>expression</em> {<em>NL</em>} <code>}</code></span>
    </dd>
    <dt><strong><em>lambdaLiteral</em>:</strong></dt>
    <dd><span class="sentence"><code>{</code> {<em>NL</em>} <em>statements</em> {<em>NL</em>} <code>}</code><br />
| <code>{</code> {<em>NL</em>} <em>lambdaParameters</em> {<em>NL</em>} <code>-&gt;</code> {<em>NL</em>} <em>statements</em> {<em>NL</em>} <code>}</code></span>
    </dd>
    <dt><strong><em>lambdaParameters</em>:</strong></dt>
    <dd><span class="sentence">[<em>lambdaParameter</em>] {{<em>NL</em>} <code>,</code> {<em>NL</em>} <em>lambdaParameter</em>}</span>
    </dd>
    <dt><strong><em>lambdaParameter</em>:</strong></dt>
    <dd><span class="sentence"><em>variableDeclaration</em><br />
| <em>multiVariableDeclaration</em> [{<em>NL</em>} <code>:</code> {<em>NL</em>} <em>type</em>]</span>
    </dd>
    <dt><strong><em>anonymousFunction</em>:</strong></dt>
    <dd><span class="sentence"><code>fun</code><br />
[{<em>NL</em>} <em>type</em> {<em>NL</em>} <code>.</code>]<br />
{<em>NL</em>} <em>functionValueParameters</em><br />
[{<em>NL</em>} <code>:</code> {<em>NL</em>} <em>type</em>]<br />
[{<em>NL</em>} <em>typeConstraints</em>]<br />
[{<em>NL</em>} <em>functionBody</em>]</span>
    </dd>
    <dt><strong><em>functionLiteral</em>:</strong></dt>
    <dd><span class="sentence"><em>lambdaLiteral</em><br />
| <em>anonymousFunction</em></span>
    </dd>
    <dt><strong><em>objectLiteral</em>:</strong></dt>
    <dd><span class="sentence"><code>object</code> {<em>NL</em>} <code>:</code> {<em>NL</em>} <em>delegationSpecifiers</em> [{<em>NL</em>} <em>classBody</em>]<br />
| <code>object</code> {<em>NL</em>} <em>classBody</em></span>
    </dd>
    <dt><strong><em>thisExpression</em>:</strong></dt>
    <dd><span class="sentence"><code>this</code> [<em>AtIdentifier</em>]</span>
    </dd>
    <dt><strong><em>superExpression</em>:</strong></dt>
    <dd><span class="sentence"><code>super</code> [<code>&lt;</code> {<em>NL</em>} <em>type</em> {<em>NL</em>} <code>&gt;</code>] [<em>AtIdentifier</em>]</span>
    </dd>
    <dt><strong><em>controlStructureBody</em>:</strong></dt>
    <dd><span class="sentence"><em>block</em><br />
| <em>statement</em></span>
    </dd>
    <dt><strong><em>whenExpression</em>:</strong></dt>
    <dd><span class="sentence"><code>when</code> {<em>NL</em>} [<code>(</code> <em>expression</em> <code>)</code>] {<em>NL</em>} <code>{</code> {<em>NL</em>} {<em>whenEntry</em> {<em>NL</em>}} {<em>NL</em>} <code>}</code></span>
    </dd>
    <dt><strong><em>whenEntry</em>:</strong></dt>
    <dd><span class="sentence"><em>whenCondition</em> {{<em>NL</em>} <code>,</code> {<em>NL</em>} <em>whenCondition</em>} {<em>NL</em>} <code>-&gt;</code> {<em>NL</em>} <em>controlStructureBody</em> [<em>semi</em>]<br />
| <code>else</code> {<em>NL</em>} <code>-&gt;</code> {<em>NL</em>} <em>controlStructureBody</em> [<em>semi</em>]</span>
    </dd>
    <dt><strong><em>whenCondition</em>:</strong></dt>
    <dd><span class="sentence"><em>expression</em><br />
| <em>rangeTest</em><br />
| <em>typeTest</em></span>
    </dd>
    <dt><strong><em>rangeTest</em>:</strong></dt>
    <dd><span class="sentence"><em>inOperator</em> {<em>NL</em>} <em>expression</em></span>
    </dd>
    <dt><strong><em>typeTest</em>:</strong></dt>
    <dd><span class="sentence"><em>isOperator</em> {<em>NL</em>} <em>type</em></span>
    </dd>
    <dt><strong><em>tryExpression</em>:</strong></dt>
    <dd><span class="sentence"><code>try</code> {<em>NL</em>} <em>block</em> {{<em>NL</em>} <em>catchBlock</em>} [{<em>NL</em>} <em>finallyBlock</em>]</span>
    </dd>
    <dt><strong><em>catchBlock</em>:</strong></dt>
    <dd><span class="sentence"><code>catch</code> {<em>NL</em>} <code>(</code> {<em>annotation</em>} <em>simpleIdentifier</em> <code>:</code> <em>userType</em> <code>)</code> {<em>NL</em>} <em>block</em></span>
    </dd>
    <dt><strong><em>finallyBlock</em>:</strong></dt>
    <dd><span class="sentence"><code>finally</code> {<em>NL</em>} <em>block</em></span>
    </dd>
    <dt><strong><em>loopStatement</em>:</strong></dt>
    <dd><span class="sentence"><em>forStatement</em><br />
| <em>whileStatement</em><br />
| <em>doWhileStatement</em></span>
    </dd>
    <dt><strong><em>forStatement</em>:</strong></dt>
    <dd><span class="sentence"><code>for</code> {<em>NL</em>} <code>(</code> {<em>annotation</em>} (variableDeclaration | <em>multiVariableDeclaration</em>) <code>in</code> <em>expression</em> <code>)</code> {<em>NL</em>} [<em>controlStructureBody</em>]</span>
    </dd>
    <dt><strong><em>whileStatement</em>:</strong></dt>
    <dd><span class="sentence"><code>while</code> {<em>NL</em>} <code>(</code> <em>expression</em> <code>)</code> {<em>NL</em>} <em>controlStructureBody</em><br />
| <code>while</code> {<em>NL</em>} <code>(</code> <em>expression</em> <code>)</code> {<em>NL</em>} <code>;</code></span>
    </dd>
    <dt><strong><em>doWhileStatement</em>:</strong></dt>
    <dd><span class="sentence"><code>do</code> {<em>NL</em>} [<em>controlStructureBody</em>] {<em>NL</em>} <code>while</code> {<em>NL</em>} <code>(</code> <em>expression</em> <code>)</code></span>
    </dd>
    <dt><strong><em>jumpExpression</em>:</strong></dt>
    <dd><span class="sentence"><code>throw</code> {<em>NL</em>} <em>expression</em><br />
| (<code>return</code> | <code>return@</code> <em>Identifier</em>) [<em>expression</em>]<br />
| <code>continue</code> | <code>continue@</code> <em>Identifier</em><br />
| <code>break</code> | <code>break@</code> <em>Identifier</em></span>
    </dd>
    <dt><strong><em>callableReference</em>:</strong></dt>
    <dd><span class="sentence">[<em>receiverType</em>] {<em>NL</em>} (<code>::</code>|<code>?::</code>) {<em>NL</em>} (<em>simpleIdentifier</em> | <code>class</code>)</span>
    </dd>
    <dt><strong><em>assignmentAndOperator</em>:</strong></dt>
    <dd><span class="sentence"><code>=</code><br />
| <code>+=</code><br />
| <code>-=</code><br />
| <code>*=</code><br />
| <code>/=</code><br />
| <code>%=</code></span>
    </dd>
    <dt><strong><em>equalityOperator</em>:</strong></dt>
    <dd><span class="sentence"><code>!=</code><br />
| <code>!==</code><br />
| <code>==</code><br />
| <code>===</code></span>
    </dd>
    <dt><strong><em>comparisonOperator</em>:</strong></dt>
    <dd><span class="sentence"><code>&lt;</code><br />
| <code>&gt;</code><br />
| <code>&lt;=</code><br />
| <code>&gt;=</code></span>
    </dd>
    <dt><strong><em>inOperator</em>:</strong></dt>
    <dd><span class="sentence"><code>in</code> | <code>!in</code></span>
    </dd>
    <dt><strong><em>isOperator</em>:</strong></dt>
    <dd><span class="sentence"><code>is</code> | <code>!is</code></span>
    </dd>
    <dt><strong><em>additiveOperator</em>:</strong></dt>
    <dd><span class="sentence"><code>+</code> | <code>-</code></span>
    </dd>
    <dt><strong><em>multiplicativeOperator</em>:</strong></dt>
    <dd><span class="sentence"><code>*</code><br />
| <code>/</code><br />
| <code>%</code></span>
    </dd>
    <dt><strong><em>asOperator</em>:</strong></dt>
    <dd><span class="sentence"><code>as</code><br />
| <code>as?</code><br />
| <code>:</code></span>
    </dd>
    <dt><strong><em>prefixUnaryOperator</em>:</strong></dt>
    <dd><span class="sentence"><code>++</code><br />
| <code>--</code><br />
| <code>-</code><br />
| <code>+</code><br />
| <code>!</code></span>
    </dd>
    <dt><strong><em>postfixUnaryOperator</em>:</strong></dt>
    <dd><span class="sentence"><code>++</code><br />
| <code>--</code><br />
| <code>!!</code></span>
    </dd>
    <dt><strong><em>memberAccessOperator</em>:</strong></dt>
    <dd><span class="sentence"><code>.</code> | <code>?.</code> | <code>::</code></span>
    </dd>
    <dt><strong><em>modifierList</em>:</strong></dt>
    <dd><span class="sentence">(<em>annotation</em> | <em>modifier</em>) {<em>annotation</em> | <em>modifier</em>}</span>
    </dd>
    <dt><strong><em>modifier</em>:</strong></dt>
    <dd><span class="sentence">(<em>classModifier</em><br />
| <em>memberModifier</em><br />
| <em>visibilityModifier</em><br />
| <em>varianceAnnotation</em><br />
| <em>functionModifier</em><br />
| <em>propertyModifier</em><br />
| <em>inheritanceModifier</em><br />
| <em>parameterModifier</em><br />
| <em>typeParameterModifier</em><br />
| <em>platformModifier</em>) {<em>NL</em>}</span>
    </dd>
    <dt><strong><em>classModifier</em>:</strong></dt>
    <dd><span class="sentence"><code>enum</code><br />
| <code>sealed</code><br />
| <code>annotation</code><br />
| <code>data</code><br />
| <code>inner</code></span>
    </dd>
    <dt><strong><em>memberModifier</em>:</strong></dt>
    <dd><span class="sentence"><code>override</code><br />
| <code>lateinit</code></span>
    </dd>
    <dt><strong><em>visibilityModifier</em>:</strong></dt>
    <dd><span class="sentence"><code>public</code><br />
| <code>private</code><br />
| <code>internal</code><br />
| <code>protected</code></span>
    </dd>
    <dt><strong><em>varianceAnnotation</em>:</strong></dt>
    <dd><span class="sentence"><code>in</code><br />
| <code>out</code></span>
    </dd>
    <dt><strong><em>functionModifier</em>:</strong></dt>
    <dd><span class="sentence"><code>tailrec</code><br />
| <code>operator</code><br />
| <code>infix</code><br />
| <code>inline</code><br />
| <code>external</code><br />
| <code>suspend</code></span>
    </dd>
    <dt><strong><em>propertyModifier</em>:</strong></dt>
    <dd><span class="sentence"><code>const</code></span>
    </dd>
    <dt><strong><em>inheritanceModifier</em>:</strong></dt>
    <dd><span class="sentence"><code>abstract</code><br />
| <code>final</code><br />
| <code>open</code></span>
    </dd>
    <dt><strong><em>parameterModifier</em>:</strong></dt>
    <dd><span class="sentence"><code>vararg</code><br />
| <code>noinline</code><br />
| <code>crossinline</code></span>
    </dd>
    <dt><strong><em>typeParameterModifier</em>:</strong></dt>
    <dd><span class="sentence"><code>reified</code></span>
    </dd>
    <dt><strong><em>platformModifier</em>:</strong></dt>
    <dd><span class="sentence"><code>expect</code><br />
| <code>actual</code></span>
    </dd>
    <dt><strong><em>labelDefinition</em>:</strong></dt>
    <dd><span class="sentence"><em>IdentifierAt</em> {<em>NL</em>}</span>
    </dd>
    <dt><strong><em>annotation</em>:</strong></dt>
    <dd><span class="sentence">(singleAnnotation | <em>multiAnnotation</em>) {<em>NL</em>}</span>
    </dd>
    <dt><strong><em>singleAnnotation</em>:</strong></dt>
    <dd><span class="sentence"><em>annotationUseSiteTarget</em> <code>:</code> {<em>NL</em>} <em>unescapedAnnotation</em><br />
| <em>AtIdentifier</em> {{<em>NL</em>} <code>.</code> <em>simpleIdentifier</em>} [<em>typeArguments</em>] [<em>valueArguments</em>]</span>
    </dd>
    <dt><strong><em>multiAnnotation</em>:</strong></dt>
    <dd><span class="sentence"><em>annotationUseSiteTarget</em> <code>:</code> <code>[</code> <em>unescapedAnnotation</em> {<em>unescapedAnnotation</em>} <code>]</code><br />
| <code>@[</code> <em>unescapedAnnotation</em>+ <code>]</code></span>
    </dd>
    <dt><strong><em>annotationUseSiteTarget</em>:</strong></dt>
    <dd><span class="sentence"><code>@field</code><br />
| <code>@file</code><br />
| <code>@property</code><br />
| <code>@get</code><br />
| <code>@set</code><br />
| <code>@receiver</code><br />
| <code>@param</code><br />
| <code>@setparam</code><br />
| <code>@delegate</code></span>
    </dd>
    <dt><strong><em>unescapedAnnotation</em>:</strong></dt>
    <dd><span class="sentence"><em>identifier</em> [<em>typeArguments</em>] [<em>valueArguments</em>]</span>
    </dd>
    <dt><strong><em>simpleIdentifier</em>:</strong></dt>
    <dd><span class="sentence"><em>IdentifierOrSoftKey</em></span>
    </dd>
    <dt><strong><em>identifier</em>:</strong></dt>
    <dd><span class="sentence"><em>simpleIdentifier</em> {{<em>NL</em>} <code>.</code> <em>simpleIdentifier</em>}</span>
    </dd>
    <dt><strong><em>shebangLine</em>:</strong></dt>
    <dd><span class="sentence"><em>ShebangLine</em></span>
    </dd>
    <dt><strong><em>semi</em>:</strong></dt>
    <dd><span class="sentence">(<code>;</code> | <em>NL</em>) {<em>NL</em>}<br />
| <em>EOF</em></span>
    </dd>
    <dt><strong><em>semis</em>:</strong></dt>
    <dd><span class="sentence">(<code>;</code> | <em>NL</em>) {<code>;</code> | <em>NL</em>}<br />
| <em>EOF</em></span>
    </dd>
</dl>
<h2 id="type-system">Type system</h2>
<div class="paragraph">
    <p><span class="sentence">TODO(Add examples)</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">TODO(Add grammar snippets?)</span></p>
</div>
<h3 id="glossary-1">Glossary</h3>
<div class="paragraph">
    <p><span class="sentence">TODO(Cleanup)</span></p>
</div>
<dl>
    <dt><span class="math inline">\(T\)</span></dt>
    <dd><span class="sentence">Type</span>
    </dd>
    <dt><span class="math inline">\(T!!\)</span></dt>
    <dd><span class="sentence">Non-nullable type</span>
    </dd>
    <dt><span class="math inline">\(T?\)</span></dt>
    <dd><span class="sentence">Nullable type</span>
    </dd>
    <dt><span class="math inline">\(\{T!!\}\)</span></dt>
    <dd><span class="sentence">Universe of non-nullable types</span>
    </dd>
    <dt><span class="math inline">\(\{T?\}\)</span></dt>
    <dd><span class="sentence">Universe of nullable types</span>
    </dd>
    <dt><span class="math inline">\(\Gamma\)</span></dt>
    <dd><span class="sentence">Type context</span>
    </dd>
    <dt><span class="math inline">\(T\lbrack S_1, \ldots, S_n\rbrack\)</span></dt>
    <dd><span class="sentence">The result of type argument substitution for type <span class="math inline">\(T\)</span> with types <span class="math inline">\(S_i\)</span></span>
    </dd>
    <dt>Type parameter</dt>
    <dd><span class="sentence">Formal type argument of parameterized type</span>
    </dd>
    <dt>Type argument</dt>
    <dd><span class="sentence">Actual type argument in parameterized type constructor application</span>
    </dd>
    <dt>PACT</dt>
    <dd><span class="sentence">Parameterized abstract classifier type</span>
    </dd>
    <dt>iPACT</dt>
    <dd><span class="sentence">Instantiated parameterized concrete classifier type</span>
    </dd>
</dl>
<h3 id="introduction-1">Introduction</h3>
<div class="paragraph">
    <p><span class="sentence">Kotlin has a type system with the following main properties.</span></p>
</div>
<ul>
    <li><span class="sentence">Hybrid static and gradual type checking</span></li>
    <li><span class="sentence">Null safety</span></li>
    <li><span class="sentence">No unsafe implicit conversions</span></li>
    <li><span class="sentence">Unified root type</span></li>
    <li><span class="sentence">Nominal subtyping with bounded parametric polymorphism and mixed-site variance</span></li>
</ul>
<div class="paragraph">
    <p><span class="sentence">TODO(static type checking, gradual type checking)</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">Null safety is enforced by having two type universes â€” <em>nullable</em> (with nullable types <span class="math inline">\(T?\)</span>) and <em>non-nullable</em> (with non-nullable types <span class="math inline">\(T!!\)</span>). </span><span class="sentence">All operations within the non-nullable type universe are safe, i.e., should never cause a runtime null pointer error.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">Implicit conversions between types in Kotlin are limited to safe upcasts w.r.t. </span><span class="sentence">subtyping, meaning all other (unsafe) conversions must be explicit, done via either a conversion function or an <a href="#cast-expression">explicit cast</a>. </span><span class="sentence">However, Kotlin also supports smart casts â€” a special kind of implicit conversions which are safe w.r.t. </span><span class="sentence">program control- and data-flow, which are covered in more detail <a href="#smart-casts">here</a>.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">The unified supertype type for all types in Kotlin is <code>kotlin.Any?</code>, a nullable version of <a href="#kotlin.any">kotlin.Any</a>.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">Kotlin uses nominal subtyping, meaning subtyping relation is defined when a type is declared, with bounded parametric polymorphism, implemented as <a href="#generics">generics</a> via <a href="#parameterized-classifier-types">parameterized types</a>. </span><span class="sentence">Subtyping between these parameterized types is defined through <a href="#mixed-site-variance">mixed-site variance</a>.</span></p>
</div>
<h3 id="type-kinds">Type kinds</h3>
<div class="paragraph">
    <p><span class="sentence">For the purposes of this section, we establish the following type kinds â€” different flavours of types which exist in the Kotlin type system.</span></p>
</div>
<ul>
    <li><span class="sentence"><a href="#built-in-types">Built-in types</a></span></li>
    <li><span class="sentence"><a href="#classifier-types">Classifier types</a></span></li>
    <li><span class="sentence"><a href="#function-types">Function types</a></span></li>
    <li><span class="sentence"><a href="#array-types">Array types</a></span></li>
    <li><span class="sentence"><a href="#flexible-types">Flexible types</a></span></li>
    <li><span class="sentence"><a href="#nullable-types">Nullable types</a></span></li>
    <li><span class="sentence">TODO(Intersection and union types)</span></li>
    <li><span class="sentence">TODO(Error / invalid types)</span></li>
</ul>
<div class="paragraph">
    <p><span class="sentence">We distinguish between <em>concrete</em> and <em>abstract</em> types. </span><span class="sentence">Concrete types are types which are assignable to values; abstract types either need to be instantiated as concrete types before they can be used as value types, or are used internally by the type system and are not directly denotable.</span></p>
</div>
<h4 id="built-in-types">Built-in types</h4>
<div class="paragraph">
    <p><span class="sentence">Kotlin type system uses the following built-in types, which have special semantics and representation (or lack thereof).</span></p>
</div>
<h5 id="kotlin.any"><code>kotlin.Any</code></h5>
<div class="paragraph">
    <p><span class="sentence"><code>kotlin.Any</code> is the unified supertype (<span class="math inline">\(\top\)</span>) for <span class="math inline">\(\{T!!\}\)</span>, i.e., all non-nullable types are subtypes of <code>kotlin.Any</code>, either explicitly, implicitly, or by subtyping relation.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">TODO(<code>kotlin.Any</code> members?)</span></p>
</div>
<h5 id="kotlin.nothing"><code>kotlin.Nothing</code></h5>
<div class="paragraph">
    <p><span class="sentence"><code>kotlin.Nothing</code> is the unified subtype (<span class="math inline">\(\bot\)</span>) for <span class="math inline">\(\{T!!\}\)</span>, i.e., <code>kotlin.Nothing</code> is a subtype of all non-nullable types, including user-defined ones. </span><span class="sentence">This makes it an uninhabited type (as it is impossible for anything to be, for example, a function and an integer at the same time), meaning instances of this type can never exist at runtime; subsequently, there is no way to create an instance of <code>kotlin.Nothing</code> in Kotlin.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">As the evaluation of an expression with <code>kotlin.Nothing</code> type can never complete normally, it is used to mark special situations, such as:</span></p>
</div>
<ul>
    <li><span class="sentence">non-terminating expressions</span></li>
    <li><span class="sentence">exceptional control flow</span></li>
    <li><span class="sentence">control flow transfer</span></li>
</ul>
<div class="paragraph">
    <p><span class="sentence">Additional details about how <code>kotlin.Nothing</code> should be processed are available <a href="#control--and-data-flow-analysis">here</a>.</span></p>
</div>
<h5 id="kotlin.unit"><code>kotlin.Unit</code></h5>
<div class="paragraph">
    <p><span class="sentence"><code>kotlin.Unit</code> is a unit type, i.e., a type with only one value <code>kotlin.Unit</code>; all values of type <code>kotlin.Unit</code> should reference the same underlying <code>kotlin.Unit</code> object.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">TODO(Compare to <code>void</code>?)</span></p>
</div>
<h4 id="classifier-types">Classifier types</h4>
<div class="paragraph">
    <p><span class="sentence">Classifier types represent regular types which are declared as [classes][Classes], [interfaces][Interfaces] or [objects][Objects]. </span><span class="sentence">As Kotlin supports <a href="#generics">generics</a>, there are two variants of classifier types: simple and parameterized.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">TODO(No objects as supertypes?)</span></p>
</div>
<h5 id="simple-classifier-types">Simple classifier types</h5>
<div class="paragraph">
    <p><span class="sentence">A simple concrete classifier type</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence"><span class="math display">\[T : S_1, \ldots, S_m\]</span></span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">consists of</span></p>
</div>
<ul>
    <li><span class="sentence">type name <span class="math inline">\(T\)</span></span></li>
    <li><span class="sentence">(optional) list of supertypes <span class="math inline">\(S_1, \ldots, S_m\)</span></span></li>
</ul>
<div class="paragraph">
    <p><span class="sentence">To represent a valid simple concrete classifier type, <span class="math inline">\(T : S_1, \ldots, S_m\)</span> should satisfy the following conditions.</span></p>
</div>
<ul>
    <li><span class="sentence"><span class="math inline">\(T\)</span> is a valid type name</span></li>
    <li><span class="sentence"><span class="math inline">\(\forall i \in [1,m]: S_i\)</span> must be concrete, non-nullable, valid type</span></li>
</ul>
<h5 id="parameterized-classifier-types">Parameterized classifier types</h5>
<div class="paragraph">
    <p><span class="sentence">A parameterized abstract classifier type (PACT)</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence"><span class="math display">\[T(F_1, \ldots, F_n) : S_1, \ldots, S_m\]</span></span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">consists of</span></p>
</div>
<ul>
    <li><span class="sentence">type constructor <span class="math inline">\(T\)</span> which takes type arguments and returns an instantiated type</span></li>
    <li><span class="sentence">type parameters <span class="math inline">\(F_1, \ldots, F_n\)</span></span></li>
    <li><span class="sentence">(optional) list of supertypes <span class="math inline">\(S_1, \ldots, S_m\)</span></span></li>
</ul>
<div class="paragraph">
    <p><span class="sentence">To represent a valid PACT, <span class="math inline">\(T(F_1, \ldots, F_n) : S_1, \ldots, S_m\)</span> should satisfy the following conditions.</span></p>
</div>
<ul>
    <li><span class="sentence"><span class="math inline">\(T\)</span> is a valid type name</span></li>
    <li><span class="sentence"><span class="math inline">\(\forall i \in [1,n]: F_i\)</span> must be one of the following kinds</span>
        <ul>
            <li><span class="sentence">[unbounded type parameter][Unbounded type parameters]</span></li>
            <li><span class="sentence">[projected type parameter][Projected type parameters]</span></li>
            <li><span class="sentence"><a href="#bounded-type-parameters">bounded type parameter</a></span></li>
        </ul></li>
    <li><span class="sentence"><span class="math inline">\(\forall j \in [1,m]: S_j[F_1, \ldots, F_n]\)</span> must be concrete, non-nullable, valid type</span></li>
</ul>
<div class="paragraph">
    <p><span class="sentence">An instantiated parameterized concrete classifier type (iPACT)</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence"><span class="math display">\[T[A_1, \ldots, A_n]\]</span></span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">consists of</span></p>
</div>
<ul>
    <li><span class="sentence">PACT <span class="math inline">\(T\)</span></span></li>
    <li><span class="sentence">type arguments <span class="math inline">\(A_1, \ldots, A_n\)</span></span></li>
</ul>
<div class="paragraph">
    <p><span class="sentence">To represent a valid iPACT, <span class="math inline">\(T[A_1, \ldots, A_n]\)</span> should satisfy the following conditions.</span></p>
</div>
<ul>
    <li><span class="sentence"><span class="math inline">\(T\)</span> is a valid PACT with <span class="math inline">\(n\)</span> type parameters</span></li>
    <li><span class="sentence"><span class="math inline">\(\forall i \in [1,n]: A_i\)</span> must be one of the following kinds</span>
        <ul>
            <li><span class="sentence">valid concrete type</span></li>
            <li><span class="sentence">valid projected type</span></li>
            <li><span class="sentence">type parameter available in the current type context <span class="math inline">\(\Gamma\)</span><br />
TODO(What is a type context?)<br />
TODO(Inner vs nested contexts)</span></li>
        </ul></li>
    <li><span class="sentence"><span class="math inline">\(\forall i \in [1,n]: A_i &lt;: F_i\)</span> where <span class="math inline">\(F_i\)</span> is the respective type parameter of <span class="math inline">\(T\)</span></span></li>
</ul>
<h5 id="type-parameters">Type parameters</h5>
<div class="paragraph">
    <p><span class="sentence">Type parameters are a special kind of abstract types, which are introduced by PACTs. </span><span class="sentence">They are valid only in the context of their declaring PACT.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">When creating an iPACT from PACT, type parameters with their respective type arguments go through <a href="#type-capturing">capturing</a> and create <em>captured</em> type arguments, which follow special rules described in more detail below.</span></p>
</div>
<h6 id="bounded-type-parameters">Bounded type parameters</h6>
<div class="paragraph">
    <p><span class="sentence">A bounded type parameter is an abstract type which is used to specify upper type bounds for type parameters and is defined as <span class="math inline">\(F &lt;: B_1, \ldots, B_n\)</span>, where <span class="math inline">\(B_i\)</span> is an i-th upper bound on type parameter <span class="math inline">\(F\)</span>.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">To represent a valid bounded type parameter of PACT <span class="math inline">\(T\)</span>, <span class="math inline">\(F &lt;: B_1, \ldots, B_n\)</span> should satisfy the following conditions.</span></p>
</div>
<ul>
    <li><span class="sentence"><span class="math inline">\(F\)</span> is a type parameter of PACT <span class="math inline">\(T\)</span></span></li>
    <li><span class="sentence"><span class="math inline">\(\forall i \in [1,n]: B_i\)</span> must be one of the following kinds</span>
        <ul>
            <li><span class="sentence">valid concrete type</span></li>
            <li><span class="sentence">a type parameter available in the current type context <span class="math inline">\(\Gamma\)</span></span></li>
        </ul></li>
</ul>
<div class="paragraph">
    <p><span class="sentence">TODO(Single generic bound allowed)</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">TODO(Only one class bound allowed)</span></p>
</div>
<h6 id="mixed-site-variance">Mixed-site variance</h6>
<div class="paragraph">
    <p><span class="sentence">To implement subtyping between parameterized types, Kotlin uses <em>mixed-site variance</em> â€” a combination of declaration- and use-site variance, which is easier to understand and reason about, compared to wildcards from Java. </span><span class="sentence">Mixed-site variance means you can specify, whether you want your parameterized type to be co-, contra- or invariant on some type parameter, both in type parameter (declaration-site) and type argument (use-site). </span><span class="sentence">For more practical discussion about mixed-site variance, we readdress you to <a href="#generics">generics</a>.</span></p>
</div>
<h6 id="declaration-site-variance">Declaration-site variance</h6>
<div class="paragraph">
    <p><span class="sentence">An invariant type parameter <span class="math inline">\(F\)</span> is an abstract type which may capture any valid type (see <a href="#subtyping">subtyping</a> for more details on variance); if one needs co- or contravariant type parameter, they need to use projected type parameters.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">To represent a valid invariant type parameter of PACT <span class="math inline">\(T\)</span>, <span class="math inline">\(F\)</span> should satisfy the following conditions.</span></p>
</div>
<ul>
    <li><span class="sentence"><span class="math inline">\(F\)</span> is a type parameter available in the current type context <span class="math inline">\(\Gamma\)</span></span></li>
</ul>
<div class="paragraph">
    <p><span class="sentence">Projected type parameters are abstract types which are used to declare a type parameter as <em>covariant</em> or <em>contravariant</em>. </span><span class="sentence">The variance information is used by <a href="#subtyping">subtyping</a> and for checking allowed operations on values of co- and contravariant type parameters.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">To represent a valid covariant type parameter <span class="math inline">\(\triangleleft F\)</span> of PACT <span class="math inline">\(T\)</span>, <span class="math inline">\(\triangleleft F\)</span> should satisfy the following conditions.</span></p>
</div>
<ul>
    <li><span class="sentence"><span class="math inline">\(F\)</span> is a type parameter available in the current type context <span class="math inline">\(\Gamma\)</span></span></li>
</ul>
<div class="paragraph">
    <p><span class="sentence">To represent a valid contravariant type parameter <span class="math inline">\(\triangleright F\)</span> of PACT <span class="math inline">\(T\)</span>, <span class="math inline">\(\triangleright F\)</span> should satisfy the following conditions.</span></p>
</div>
<ul>
    <li><span class="sentence"><span class="math inline">\(F\)</span> is a type parameter available in the current type context <span class="math inline">\(\Gamma\)</span></span></li>
</ul>
<div class="paragraph">
    <p><span class="sentence">TODO(type projections are not allowed on functions and properties)</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">TODO(no type projections on supertype type arguments)</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">TODO(conflicting projections)</span></p>
</div>
<h6 id="use-site-variance">Use-site variance</h6>
<div class="paragraph">
    <p><span class="sentence">Kotlin also supports use-site variance, by specifying the variance for type arguments. </span><span class="sentence">Just like with projected type parameters, one can have projected type arguments being co-, contra- or invariant.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">To represent a valid invariant type argument of iPACT <span class="math inline">\(T\)</span>, <span class="math inline">\(A\)</span> should satisfy the following conditions.</span></p>
</div>
<ul>
    <li><span class="sentence"><span class="math inline">\(A\)</span> must be one of the following kinds</span>
        <ul>
            <li><span class="sentence">a valid concrete type</span></li>
            <li><span class="sentence">a type parameter available in the current type context <span class="math inline">\(\Gamma\)</span></span></li>
        </ul></li>
</ul>
<div class="paragraph">
    <p><span class="sentence">To represent a valid covariant type argument <span class="math inline">\(\triangleleft A\)</span> of iPACT <span class="math inline">\(T\)</span>, <span class="math inline">\(\triangleleft A\)</span> should satisfy the following conditions.</span></p>
</div>
<ul>
    <li><span class="sentence"><span class="math inline">\(A\)</span> must be one of the following kinds</span>
        <ul>
            <li><span class="sentence">a valid concrete type</span></li>
            <li><span class="sentence">a type parameter available in the current type context <span class="math inline">\(\Gamma\)</span></span></li>
        </ul></li>
</ul>
<div class="paragraph">
    <p><span class="sentence">To represent a valid contravariant type argument <span class="math inline">\(\triangleright A\)</span> of iPACT <span class="math inline">\(T\)</span>, <span class="math inline">\(\triangleright A\)</span> should satisfy the following conditions.</span></p>
</div>
<ul>
    <li><span class="sentence"><span class="math inline">\(A\)</span> must be one of the following kinds</span>
        <ul>
            <li><span class="sentence">a valid concrete type</span></li>
            <li><span class="sentence">a type parameter available in the current type context <span class="math inline">\(\Gamma\)</span></span></li>
        </ul></li>
</ul>
<div class="paragraph">
    <p><span class="sentence">In case one cannot specify any valid type argument, but still needs to use PACT in a type-safe way, one may use <em>star-projected</em> type argument, which is roughly equivalent to a combination of <span class="math inline">\(\triangleleft \texttt{kotlin.Any?}\)</span> and <span class="math inline">\(\triangleright \texttt{kotlin.Nothing}\)</span> (for further details, see <a href="#generics">here</a>).</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">TODO(Clean-up this mess)</span></p>
</div>
<h5 id="type-capturing">Type capturing</h5>
<div class="paragraph">
    <p><span class="sentence">Type capturing (similarly to Java capturing conversion) is used when instantiating parameterized types; it creates <em>captured</em> types based on the type information of both type parameters and arguments, which present a unified view on the resulting types and simplifies further reasoning.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">For a given PACT <span class="math inline">\(T(F_1, \ldots, F_n) : S_1, \ldots, S_m\)</span>, its iPACT <span class="math inline">\(T[A_1, \ldots, A_n]\)</span> uses the following rules to create captured type <span class="math inline">\(C_i\)</span> from the type parameter <span class="math inline">\(F_i\)</span> and type argument <span class="math inline">\(A_i\)</span>.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">TODO(Does this set describe a type universe?)</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">TODO(Blah-blah about existential types?)</span></p>
</div>
<blockquote>
    <div class="paragraph">
        <p><span class="sentence">NB: A captured type <span class="math inline">\(C\)</span> may be viewed as a set of its type constraints <span class="math inline">\(\mathbb{C}\)</span>. </span><span class="sentence"><strong>All</strong> applicable rules are used to create the resulting constraint set.</span></p>
    </div>
</blockquote>
<ul>
    <li><span class="sentence">If <span class="math inline">\(\triangleleft F_i\)</span> is a covariant type parameter and <span class="math inline">\(A_i\)</span> is not a concrete type, covariant or star-projected type argument, it is an error. </span><span class="sentence">Otherwise, <span class="math inline">\(C_i &lt;: A_i\)</span>.</span></li>
    <li><span class="sentence">If <span class="math inline">\(\triangleright F_i\)</span> is a contravariant type parameter and <span class="math inline">\(A_i\)</span> is not a concrete type, contravariant or star-projected type argument, it is an error. </span><span class="sentence">Otherwise, <span class="math inline">\(C_i :&gt; A_i\)</span>.</span></li>
    <li><span class="sentence">If <span class="math inline">\(F_i &lt;: B_1, \ldots, B_n\)</span> is a bounded type parameter, <span class="math inline">\(C_i &lt;: B_i[C_1, \ldots, C_n]\)</span></span></li>
    <li><span class="sentence">If <span class="math inline">\(\triangleleft A_i\)</span> is a covariant type argument, <span class="math inline">\(C_i &lt;: A_i\)</span></span></li>
    <li><span class="sentence">If <span class="math inline">\(\triangleright A_i\)</span> is a contravariant type argument, <span class="math inline">\(C_i :&gt; A_i\)</span></span></li>
    <li><span class="sentence">If <span class="math inline">\(\star A_i\)</span> is a star-projected type argument, <span class="math inline">\(kotlin.Nothing &lt;: C_i &lt;: kotlin.Any?\)</span></span></li>
    <li><span class="sentence">Otherwise, <span class="math inline">\(C_i = A_i\)</span></span></li>
</ul>
<h4 id="function-types">Function types</h4>
<div class="paragraph">
    <p><span class="sentence">TODO(Everythingâ€¦)</span></p>
</div>
<h4 id="array-types">Array types</h4>
<div class="paragraph">
    <p><span class="sentence">TODO(Everythingâ€¦)</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">TODO(Primitive type array coercion)</span></p>
</div>
<h4 id="flexible-types">Flexible types</h4>
<div class="paragraph">
    <p><span class="sentence">Kotlin, being a multi-platform language, needs to support transparent interoperability with platform-dependent code. </span><span class="sentence">However, this presents a problem in that some platforms may not support null safety the way Kotlin does. </span><span class="sentence">To deal with this, Kotlin supports <em>gradual typing</em> in the form of flexible types.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">A flexible type represents a range of possible types between type <span class="math inline">\(L\)</span> (lower bound) and type <span class="math inline">\(U\)</span> (upper bound), written as <span class="math inline">\((L..U)\)</span>. </span><span class="sentence">One should note flexible types are abstract and <em>non-denotable</em>, i.e., one cannot explicitly declare a variable with flexible type, these types are created by the type system when needed.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">To represent a valid flexible type, <span class="math inline">\((L..U)\)</span> should satisfy the following conditions.</span></p>
</div>
<ul>
    <li><span class="sentence"><span class="math inline">\(L\)</span> and <span class="math inline">\(U\)</span> are valid concrete types</span></li>
    <li><span class="sentence"><span class="math inline">\(L &lt;: U\)</span></span></li>
    <li><span class="sentence"><span class="math inline">\(\neg (L &lt;: U)\)</span></span></li>
    <li><span class="sentence"><span class="math inline">\(L\)</span> and <span class="math inline">\(U\)</span> are <strong>not</strong> flexible types (but may contains other flexible types as part of their type signature)</span></li>
</ul>
<div class="paragraph">
    <p><span class="sentence">As the name suggests, flexible types are flexible â€” a value of type <span class="math inline">\((L..U)\)</span> can be used in any context, where one of the possible types between <span class="math inline">\(L\)</span> and <span class="math inline">\(U\)</span> is needed (for more details, see <a href="#subtyping">subtyping rules for flexible types</a>). </span><span class="sentence">However, the actual type will be a specific type between <span class="math inline">\(L\)</span> and <span class="math inline">\(U\)</span>, thus making the substitution possibly unsafe, which is why Kotlin generates dynamic assertions, when it is impossible to prove statically the safety of flexible type use.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">TODO(Details of assertion generation?)</span></p>
</div>
<h5 id="platform-types">Platform types</h5>
<div class="paragraph">
    <p><span class="sentence">TODO(Platform types as flexible types)</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">TODO(Reference for different platforms)</span></p>
</div>
<h4 id="nullable-types">Nullable types</h4>
<div class="paragraph">
    <p><span class="sentence">Kotlin supports null safety by having two type universes â€” nullable and non-nullable. </span><span class="sentence">All classifier type declarations, built-in or user-defined, create non-nullable types, i.e., types which cannot hold <code>null</code> value at runtime.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">To specify a nullable version of type <code>T</code>, one needs to use <code>T?</code> as a type. </span><span class="sentence">Redundant nullability specifiers are ignored â€” <code>T???</code> is equivalent to <code>T?</code>.</span></p>
</div>
<blockquote>
    <div class="paragraph">
        <p><span class="sentence">Informally, question mark means â€œ<span class="math inline">\(T?\)</span> may hold values of type <span class="math inline">\(T\)</span> or value <code>null</code>â€</span></p>
    </div>
</blockquote>
<div class="paragraph">
    <p><span class="sentence">To represent a valid nullable type, <span class="math inline">\(T?\)</span> should satisfy the following conditions.</span></p>
</div>
<ul>
    <li><span class="sentence"><span class="math inline">\(T\)</span> is a valid type</span></li>
</ul>
<div class="paragraph">
    <p><span class="sentence">If an operation is safe regardless of absence or presence of <code>null</code>, i.e., assignment of one nullable value to another, it can be used as-is for nullable types. </span><span class="sentence">For operations on <span class="math inline">\(T?\)</span> which may violate null safety, one has the following null-safe options:</span></p>
</div>
<ol type="1">
    <li><span class="sentence">Use safe operations</span>
        <ul>
            <li><span class="sentence"><a href="#safe-call-expression">safe call</a></span></li>
        </ul></li>
    <li><span class="sentence">Downcast from <span class="math inline">\(T?\)</span> to <span class="math inline">\(T!!\)</span></span>
        <ul>
            <li><span class="sentence"><a href="#cast-expression">unsafe cast</a></span></li>
            <li><span class="sentence"><a href="#type-check-expression">type check</a> combined with <a href="#smart-casts">smart casts</a></span></li>
            <li><span class="sentence">null check combined with <a href="#smart-casts">smart casts</a></span></li>
            <li><span class="sentence">[not-null assertion operator][Not-null assertion operator expression]</span></li>
        </ul></li>
    <li><span class="sentence">Supply a default value to use instead of <code>null</code></span>
        <ul>
            <li><span class="sentence"><a href="#elvis-operator-expression">elvis operator</a></span></li>
        </ul></li>
</ol>
<h3 id="subtyping">Subtyping</h3>
<div class="paragraph">
    <p><span class="sentence">Kotlin uses the classic notion of <em>subtyping</em> as <em>substitutability</em> â€” if <span class="math inline">\(S\)</span> is a subtype of <span class="math inline">\(T\)</span> (denoted as <span class="math inline">\(S &lt;: T\)</span>), values of type <span class="math inline">\(S\)</span> can be safely used where values of type <span class="math inline">\(T\)</span> are expected. </span><span class="sentence">The subtyping relation <span class="math inline">\(&lt;:\)</span> is:</span></p>
</div>
<ul>
    <li><span class="sentence">reflexive (<span class="math inline">\(A &lt;: A\)</span>)</span></li>
    <li><span class="sentence">transitive (<span class="math inline">\(A &lt;: B \land B &lt;: C \Rightarrow A &lt;: C\)</span>)</span></li>
</ul>
<div class="paragraph">
    <p><span class="sentence">Two types <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are <em>equivalent</em> (<span class="math inline">\(A \equiv B\)</span>), iff <span class="math inline">\(A &lt;: B \land B &lt;: A\)</span>. </span><span class="sentence">Due to the presence of flexible types, this relation is <strong>not</strong> transitive (see <a href="#subtyping-for-flexible-types">here</a> for more details).</span></p>
</div>
<h4 id="subtyping-rules">Subtyping rules</h4>
<div class="paragraph">
    <p><span class="sentence">Subtyping for non-nullable, concrete types uses the following rules.</span></p>
</div>
<ul>
    <li><span class="sentence"><span class="math inline">\(\forall T : \text{kotlin.Nothing} &lt;: T &lt;: \text{kotlin.Any}\)</span></span></li>
    <li><span class="sentence">For any simple classifier type <span class="math inline">\(T : S_1, \ldots, S_m\)</span> it is true that <span class="math inline">\(\forall i \in [1,m]: T &lt;: S_i\)</span></span></li>
    <li><span class="sentence">For any iPACT <span class="math inline">\(\widehat{T} = T(F_1, \ldots, F_n)[A_1, \ldots, A_n] : S_1, \ldots, S_m\)</span> with captured type arguments <span class="math inline">\(C_1, \ldots, C_n\)</span> it is true that <span class="math inline">\(\forall i \in [1,m]: \widehat{T} &lt;: S_i[C_1, \ldots, C_n]\)</span></span></li>
    <li><span class="sentence">For any two iPACTs <span class="math inline">\(\widehat{T}\)</span> and <span class="math inline">\(\widehat{T^\prime}\)</span> with captured type arguments <span class="math inline">\(C_i\)</span> and <span class="math inline">\(C_i^\prime\)</span> it is true that <span class="math inline">\(\widehat{T} &lt;: \widehat{T^\prime}\)</span> if <span class="math inline">\(\forall i \in [1,n]: C_i &lt;: C_i^\prime\)</span></span></li>
</ul>
<div class="paragraph">
    <p><span class="sentence">Subtyping for non-nullable, abstract types uses the following rules.</span></p>
</div>
<ul>
    <li><span class="sentence"><span class="math inline">\(\forall T : \text{kotlin.Nothing} &lt;: T &lt;: \text{kotlin.Any}\)</span></span></li>
    <li><span class="sentence">For any PACT <span class="math inline">\(\widehat{T} = T(F_1, \ldots, F_n) : S_1, \ldots, S_m\)</span> it is true that <span class="math inline">\(\forall i \in [1,m]: \widehat{T} &lt;: S_i\)</span></span></li>
</ul>
<div class="paragraph">
    <p><span class="sentence">TODO(Subtyping for type parameters)</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">Subtyping for non-nullable, captured types uses rules of different kind, as captured type <span class="math inline">\(C\)</span> describes not one, but a set of types which satisfy its type constraints <span class="math inline">\(\mathbb{C}\)</span>. </span><span class="sentence">Therefore, we use the following subtyping rules for captured types.</span></p>
</div>
<ul>
    <li><span class="sentence"><span class="math inline">\(\forall C : \text{kotlin.Nothing} &lt;: C &lt;: \text{kotlin.Any}\)</span></span></li>
    <li><span class="sentence">For any two captured types <span class="math inline">\(C\)</span> and <span class="math inline">\(C^\prime\)</span>, <span class="math inline">\(C &lt;: C^\prime\)</span> if <span class="math inline">\(\forall T : \mathbb{C}(T) \Rightarrow \mathbb{C^\prime}(T)\)</span> (i.e., a set of types for <span class="math inline">\(C\)</span> is a subset of a set of types for <span class="math inline">\(C^\prime\)</span>)</span></li>
</ul>
<div class="paragraph">
    <p><span class="sentence">Subtyping for nullable types is checked separately and uses a special set of rules which are described <a href="#subtyping-for-nullable-types">here</a>.</span></p>
</div>
<h4 id="subtyping-for-flexible-types">Subtyping for flexible types</h4>
<div class="paragraph">
    <p><span class="sentence">Flexible types (being flexible) follow a simple subtyping relation with other inflexible types. </span><span class="sentence">Let <span class="math inline">\(T, A, B, L, U\)</span> be inflexible types.</span></p>
</div>
<ul>
    <li><span class="sentence"><span class="math inline">\(L &lt;: T \Rightarrow (L..U) &lt;: T\)</span></span></li>
    <li><span class="sentence"><span class="math inline">\(T &lt;: U \Rightarrow T &lt;: (L..U)\)</span></span></li>
</ul>
<div class="paragraph">
    <p><span class="sentence">This captures the notion of flexible type <span class="math inline">\((L..U)\)</span> as something which may be used in place of any type in between <span class="math inline">\(L\)</span> and <span class="math inline">\(U\)</span>. </span><span class="sentence">If we are to extend this idea to subtyping between <em>two</em> flexible types, we get the following definition.</span></p>
</div>
<ul>
    <li><span class="sentence"><span class="math inline">\(L &lt;: B \Rightarrow (L..U) &lt;: (A..B)\)</span></span></li>
</ul>
<div class="paragraph">
    <p><span class="sentence">This is the most extensive definition possible, which, unfortunately, makes the type equivalence relation non-transitive. </span><span class="sentence">Let <span class="math inline">\(A, B\)</span> be two <em>different</em> types, for which <span class="math inline">\(A &lt;: B\)</span>. </span><span class="sentence">The following relations hold:</span></p>
</div>
<ul>
    <li><span class="sentence"><span class="math inline">\(A &lt;: (A..B) \land (A..B) &lt;: A \Rightarrow A \equiv (A..B)\)</span></span></li>
    <li><span class="sentence"><span class="math inline">\(B &lt;: (A..B) \land (A..B) &lt;: B \Rightarrow B \equiv (A..B)\)</span></span></li>
</ul>
<div class="paragraph">
    <p><span class="sentence">However, <span class="math inline">\(A \not \equiv B\)</span>.</span></p>
</div>
<h4 id="subtyping-for-nullable-types">Subtyping for nullable types</h4>
<div class="paragraph">
    <p><span class="sentence">Subtyping for two possibly nullable types <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> is defined via <em>two</em> relations, both of which must hold.</span></p>
</div>
<ul>
    <li><span class="sentence">Regular subtyping <span class="math inline">\(&lt;:\)</span> for non-nullable types <span class="math inline">\(A!!\)</span> and <span class="math inline">\(B!!\)</span></span></li>
    <li><span class="sentence">Subtyping by nullability <span class="math inline">\(\sbn\)</span></span></li>
</ul>
<div class="paragraph">
    <p><span class="sentence">Subtyping by nullability <span class="math inline">\(\sbn\)</span> for two possibly nullable types <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> uses the following rules.</span></p>
</div>
<ul>
    <li><span class="sentence"><span class="math inline">\(A!! \sbn B\)</span></span></li>
    <li><span class="sentence"><span class="math inline">\(A \sbn B\)</span> if <span class="math inline">\(\exists T!! : A &lt;: T!!\)</span></span></li>
    <li><span class="sentence"><span class="math inline">\(A \sbn B?\)</span></span></li>
    <li><span class="sentence"><span class="math inline">\(A \sbn B\)</span> if <span class="math inline">\(\not \exists T!! : B &lt;: T!!\)</span></span></li>
</ul>
<div class="paragraph">
    <p><span class="sentence">TODO(How the existence check works)</span></p>
</div>
<h3 id="generics">Generics</h3>
<div class="paragraph">
    <p><span class="sentence">TODO(Here be a lot of dragonsâ€¦)</span></p>
</div>
<h3 id="references">References</h3>
<ol type="1">
    <li><span class="sentence">Tate, Ross. </span><span class="sentence">â€œMixed-site variance.â€ FOOL, 2013.</span></li>
</ol>
<h2 id="declarations">Declarations</h2>
<div class="paragraph">
    <p><span class="sentence">TODO(Examples)</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">Declarations in Kotlin are used to introduce entities (values, types, etc.); most declarations are <em>named</em>, i.e.Â they also assign an identifier to their own entity, however, some declarations may be <em>anonymous</em>.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">Every declaration is accessible in a particular <em>scope</em>, which is dependent both on where the declaration is located and on the declaration itself.</span></p>
</div>
<h3 id="classifier-declaration">Classifier declaration</h3>
<dl>
    <dt><strong><em>classDeclaration</em>:</strong></dt>
    <dd><span class="sentence">[<em>modifierList</em>] (<code>class</code> | <code>interface</code>) {<em>NL</em>} <em>simpleIdentifier</em><br />
[{<em>NL</em>} <em>typeParameters</em>] [{<em>NL</em>} <em>primaryConstructor</em>]<br />
[{<em>NL</em>} <code>:</code> {<em>NL</em>} <em>delegationSpecifiers</em>]<br />
[{<em>NL</em>} <em>typeConstraints</em>]<br />
[{<em>NL</em>} <em>classBody</em> | {<em>NL</em>} <em>enumClassBody</em>]</span>
    </dd>
    <dt><strong><em>objectDeclaration</em>:</strong></dt>
    <dd><span class="sentence">[<em>modifierList</em>] <code>object</code><br />
{<em>NL</em>} <em>simpleIdentifier</em><br />
[{<em>NL</em>} <code>:</code> {<em>NL</em>} <em>delegationSpecifiers</em>]<br />
[{<em>NL</em>} <em>classBody</em>]</span>
    </dd>
</dl>
<h3 id="function-declaration">Function declaration</h3>
<dl>
    <dt><strong><em>functionDeclaration</em>:</strong></dt>
    <dd><span class="sentence">[<em>modifierList</em>]<br />
<code>fun</code><br />
[{<em>NL</em>} <em>typeParameters</em>]<br />
[{<em>NL</em>} <em>type</em> {<em>NL</em>} <code>.</code>] ({<em>NL</em>} <em>simpleIdentifier</em>)<br />
{<em>NL</em>} <em>functionValueParameters</em><br />
[{<em>NL</em>} <code>:</code> {<em>NL</em>} <em>type</em>]<br />
[{<em>NL</em>} <em>typeConstraints</em>]<br />
[{<em>NL</em>} <em>functionBody</em>]</span>
    </dd>
</dl>
<div class="paragraph">
    <p><span class="sentence">Function declarations assign names to such entities as functions â€” blocks of code which may be called by passing them a number of arguments. </span><span class="sentence">Functions have special <em>function types</em> which are covered in more detail <a href="#function-types">here</a>.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">A simple function declaration consists of four main parts</span></p>
</div>
<ul>
    <li><span class="sentence">name <span class="math inline">\(f\)</span></span></li>
    <li><span class="sentence">parameter list <span class="math inline">\((p_1: P_1 = v_1, \ldots, p_n: P_n = v_n)\)</span></span></li>
    <li><span class="sentence">return type <span class="math inline">\(R\)</span></span></li>
    <li><span class="sentence">body <span class="math inline">\(b\)</span></span></li>
</ul>
<div class="paragraph">
    <p><span class="sentence">and creates a function type <span class="math inline">\((P_1, \ldots, P_n) \rightarrow R\)</span>.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">Parameter list <span class="math inline">\((p_1: P_1 = v_1, \ldots, p_n: P_n = v_n)\)</span> describes function parameters â€” inputs needed to execute the declared function. </span><span class="sentence">Each parameter <span class="math inline">\(p_i: P_i = v_i\)</span> introduces <span class="math inline">\(p_i\)</span> as a name of value with type <span class="math inline">\(P_i\)</span> available inside function body <span class="math inline">\(b\)</span>. </span><span class="sentence">A function may have zero or more parameters.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">A parameter may include a default value <span class="math inline">\(v_i\)</span>, which is used if the corresponding argument is not specified in function invocation; <span class="math inline">\(v_i\)</span> should be an expression which evaluates to type <span class="math inline">\(V &lt;: P_i\)</span>.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">Return type <span class="math inline">\(R\)</span> is optional, if function body <span class="math inline">\(b\)</span> is present and may be inferred to have a valid type <span class="math inline">\(B : B \not \equiv kotlin.Nothing\)</span>, in which case <span class="math inline">\(R \equiv B\)</span>. </span><span class="sentence">In other cases return type <span class="math inline">\(R\)</span> must be specified explicitly.</span></p>
</div>
<blockquote>
    <div class="paragraph">
        <p><span class="sentence">As type <span class="math inline">\(kotlin.Nothing\)</span> has a <a href="#kotlin.nothing">special meaning</a> in Kotlin type system, it must be specified explicitly, to avoid spurious <span class="math inline">\(kotlin.Nothing\)</span> function return types.</span></p>
    </div>
</blockquote>
<div class="paragraph">
    <p><span class="sentence">Function body <span class="math inline">\(b\)</span> is optional; if it is ommited, a function declaration creates an <em>abstract</em> function, which does not have an implementation. </span><span class="sentence">This is allowed only inside an <a href="#classifier-declaration">abstract classifier declaration</a>. </span><span class="sentence">If a function body <span class="math inline">\(b\)</span> is present, it should evaluate to type <span class="math inline">\(B\)</span> which should satisfy <span class="math inline">\(B &lt;: R\)</span>.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">A parameterized function declaration consists of five main parts</span></p>
</div>
<ul>
    <li><span class="sentence">name <span class="math inline">\(f\)</span></span></li>
    <li><span class="sentence">type parameter list <span class="math inline">\(T_1, \ldots, T_m\)</span></span></li>
    <li><span class="sentence">parameter list <span class="math inline">\((p_1: P_1 = v_1, \ldots, p_n: P_n = v_n)\)</span></span></li>
    <li><span class="sentence">return type <span class="math inline">\(R\)</span></span></li>
    <li><span class="sentence">body <span class="math inline">\(b\)</span></span></li>
</ul>
<div class="paragraph">
    <p><span class="sentence">and extends the rules for a simple function declaration w.r.t. </span><span class="sentence">type parameter list.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">TODO(type parameters)</span></p>
</div>
<h4 id="named-and-positional-parameters">Named and positional parameters</h4>
<div class="paragraph">
    <p><span class="sentence">TODO()</span></p>
</div>
<h4 id="variable-length-parameters">Variable length parameters</h4>
<div class="paragraph">
    <p><span class="sentence">One of the parameters may be designated as being variable length (aka <em>vararg</em>). </span><span class="sentence">A parameter list <span class="math inline">\((p_1, \ldots, \text{vararg }p_i: P_i = v_i, \ldots, p_n)\)</span> means a function may be called with any number of arguments in the i-th position. </span><span class="sentence">These arguments are represented inside function body <span class="math inline">\(b\)</span> as an <a href="#array-types">array of type <span class="math inline">\(P_i\)</span></a>.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">If a variable length parameter is not last in the parameter list, all subsequent arguments in the function invocation should be specified as named arguments. </span><span class="sentence">If a variable length parameter has a default value, it should be an expression which evaluates to an <a href="#array-types">array of type <span class="math inline">\(P_i\)</span></a>.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">An array of type <span class="math inline">\(Q &lt;: P_i\)</span> may be <em>unpacked</em> to a variable length parameter in function invocation using <a href="#spread-operator">spread operator</a>; in this case array elements are considered to be separate arguments in the variable length parameter position. </span><span class="sentence">A function invocation may include several spread operator expressions corresponding to the vararg parameter.</span></p>
</div>
<h4 id="function-type-parameters">Function type parameters</h4>
<div class="paragraph">
    <p><span class="sentence">TODO()</span></p>
</div>
<h4 id="extension-function-declaration">Extension function declaration</h4>
<div class="paragraph">
    <p><span class="sentence">TODO()</span></p>
</div>
<h3 id="property-declaration">Property declaration</h3>
<dl>
    <dt><strong><em>propertyDeclaration</em>:</strong></dt>
    <dd><span class="sentence">[<em>modifierList</em>] (<code>val</code> | <code>var</code>)<br />
[{<em>NL</em>} <em>typeParameters</em>]<br />
[{<em>NL</em>} <em>type</em> {<em>NL</em>} <code>.</code>]<br />
({<em>NL</em>} (<em>multiVariableDeclaration</em> | <em>variableDeclaration</em>))<br />
[{<em>NL</em>} <em>typeConstraints</em>]<br />
[{<em>NL</em>} (<code>by</code> | <code>=</code>) {<em>NL</em>} <em>expression</em>]<br />
[NL+ <code>;</code>] {<em>NL</em>} [[<em>getter</em>] ({<em>NL</em>} [<em>semi</em>] <em>setter</em>] | [<em>setter</em>] [{<em>NL</em>} [<em>semi</em>] <em>getter</em>])</span>
    </dd>
</dl>
<div class="paragraph">
    <p><span class="sentence">Property declarations are used to create read-only (<code>val</code>) or mutable (<code>var</code>) entities in their respective scope. </span><span class="sentence">Properties may also have custom getter or setter â€” functions which are used to read or write the property value.</span></p>
</div>
<h4 id="read-only-property-declaration">Read-only property declaration</h4>
<div class="paragraph">
    <p><span class="sentence">A read-only property declaration <code>val x: T = e</code> introduces <code>x</code> as a name of the result of <code>e</code>. </span><span class="sentence">Both the right-hand value <code>e</code> and the type <code>T</code> are optional, however, at least one of them must be specified. </span><span class="sentence">More so, if the type of <code>e</code> cannot be <a href="#type-inference">inferred</a>, the type <code>T</code> must be specified explicitly. </span><span class="sentence">In case both are specified, the type of <code>e</code> must be a subtype of <code>T</code> (see <a href="#subtyping">subtyping</a> for more details).</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">A read-only property declaration may include a custom <a href="#getters-and-setters">getter</a> in the form of</span></p>
</div>
<div class="sourceCode" id="cb1"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">val</span> <span class="va">x</span>: T = e</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">    <span class="kw">get</span>() { ... }</a></code></pre></div>
<div class="paragraph">
    <p><span class="sentence">in which case <code>x</code> is used as a synonym to the getter invocation.</span></p>
</div>
<h4 id="mutable-property-declaration">Mutable property declaration</h4>
<div class="paragraph">
    <p><span class="sentence">A mutable property declaration <code>var x: T = e</code> introduces <code>x</code> as a name of a mutable variable with type <code>T</code> and initial value equals to the result of <code>e</code>. </span><span class="sentence">The rules regarding the right-hand value <code>e</code> and the type <code>T</code> match those of a read-only property declaration.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">A mutable property declaration may include a custom <a href="#getters-and-setters">getter</a> and/or custom <a href="#getters-and-setters">setter</a> in the form of</span></p>
</div>
<div class="sourceCode" id="cb2"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">var</span> <span class="va">x</span>: T = e</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">    <span class="kw">get</span>(): TG { ... }</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">    <span class="kw">set</span>(value: TS) { ... }</a></code></pre></div>
<div class="paragraph">
    <p><span class="sentence">in which case <code>x</code> is used as a synonym to the getter invocation when read from and to the setter invocation when written to.</span></p>
</div>
<h4 id="delegated-property-declaration">Delegated property declaration</h4>
<div class="paragraph">
    <p><span class="sentence">A delegated read-only property declaration <code>val x: T by e</code> introduces <code>x</code> as a name for the <em>delegation</em> result of property <code>x</code> to the entity <code>e</code>. </span><span class="sentence">One may view these properties as regular properties with a special <em>delegating</em> <a href="#getters-and-setters">getters</a>. </span><span class="sentence">TODO(Type is optional if inferred?)</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">In case of a delegated read-only property, access to <code>x</code> is replaced with the call to a special function <code>getValue</code>, which must be available on <code>e</code>. </span><span class="sentence">This function has the following signature</span></p>
</div>
<div class="sourceCode" id="cb3"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">operator</span> <span class="kw">fun</span> <span class="fu">getValue</span>(<span class="va">thisRef</span>: <span class="dt">E</span>, <span class="va">property</span>: <span class="dt">PropertyInfo</span>): <span class="dt">R</span></a></code></pre></div>
<div class="paragraph">
    <p><span class="sentence">where</span></p>
</div>
<ul>
    <li><span class="sentence"><code>thisRef: E</code> is the reference to the enclosing entity</span>
        <ul>
            <li><span class="sentence">holds the enclosing class or object instance in case of classifier property</span></li>
            <li><span class="sentence">is <code>null</code> for <a href="#local-property-declaration">local properties</a></span></li>
        </ul></li>
    <li><span class="sentence"><code>property: PropertyInfo</code> contains runtime-available information about the declared property, most importantly</span>
        <ul>
            <li><span class="sentence"><code>property.name</code> holds the property name</span></li>
        </ul></li>
</ul>
<div class="paragraph">
    <p><span class="sentence">This convention implies the following requirements on the <code>getValue</code> function</span></p>
</div>
<ul>
    <li><span class="sentence"><span class="math inline">\(S &lt;: E\)</span>, where <span class="math inline">\(S\)</span> is the type of the enclosing entity</span></li>
    <li><span class="sentence"><span class="math inline">\(\text{KProperty&lt;*&gt;} &lt;: \text{PropertyInfo}\)</span></span></li>
    <li><span class="sentence"><span class="math inline">\(R\)</span> should be in a supertype relation with the delegated property type <span class="math inline">\(T\)</span></span></li>
</ul>
<blockquote>
    <div class="paragraph">
        <p><span class="sentence">In case of the local property, enclosing entity has the type <code>Nothing?</code></span></p>
    </div>
</blockquote>
<div class="paragraph">
    <p><span class="sentence">A delegated mutable property declaration <code>var x: T by e</code> introduces <code>x</code> as a name of a mutable entity with type <code>T</code>, access to which is <em>delegated</em> to the entity <code>e</code>. </span><span class="sentence">As before, one may view these properties as regular properties with special <em>delegating</em> <a href="#getters-and-setters">getters and setters</a>.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">Read access is handeled using the same <code>getValue</code> function as for a delegated read-only property. </span><span class="sentence">Write access is processed using a special function <code>setValue</code>, which must be available on <code>e</code>. </span><span class="sentence">This function has the following signature</span></p>
</div>
<div class="sourceCode" id="cb4"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">operator</span> <span class="kw">fun</span> <span class="fu">setValue</span>(<span class="va">thisRef</span>: <span class="dt">E</span>, <span class="va">property</span>: <span class="dt">PropertyInfo</span>, <span class="va">value</span>: <span class="dt">R</span>): <span class="dt">U</span></a></code></pre></div>
<div class="paragraph">
    <p><span class="sentence">where</span></p>
</div>
<ul>
    <li><span class="sentence"><code>thisRef: E</code> is the reference to the enclosing entity</span>
        <ul>
            <li><span class="sentence">holds the enclosing class or object instance in case of classifier property</span></li>
            <li><span class="sentence">is <code>null</code> for <a href="#local-property-declaration">local properties</a></span></li>
        </ul></li>
    <li><span class="sentence"><code>property: PropertyInfo</code> contains runtime-available information about the declared property, most importantly</span>
        <ul>
            <li><span class="sentence"><code>property.name</code> holds the property name</span></li>
        </ul></li>
    <li><span class="sentence"><code>value: R</code> is the new property value</span></li>
</ul>
<div class="paragraph">
    <p><span class="sentence">This convention implies the following requirements on the <code>setValue</code> function</span></p>
</div>
<ul>
    <li><span class="sentence"><span class="math inline">\(S &lt;: E\)</span>, where <span class="math inline">\(S\)</span> is the type of the enclosing entity</span></li>
    <li><span class="sentence"><span class="math inline">\(\text{KProperty&lt;*&gt;} &lt;: \text{PropertyInfo}\)</span></span></li>
    <li><span class="sentence"><span class="math inline">\(R\)</span> should be in a supertype relation with the delegated property type <span class="math inline">\(T\)</span></span></li>
    <li><span class="sentence"><span class="math inline">\(U\)</span> is ignored</span></li>
</ul>
<blockquote>
    <div class="paragraph">
        <p><span class="sentence">In case of the local property, enclosing entity has the type <code>Nothing?</code></span></p>
    </div>
</blockquote>
<div class="paragraph">
    <p><span class="sentence">The delegated property is expanded as follows.</span></p>
</div>
<div class="sourceCode" id="cb5"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="co"> * Actual code</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="co"> */</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4"><span class="kw">class</span> C {</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">    <span class="kw">var</span> <span class="va">prop</span>: Type <span class="kw">by</span> DelegateExpression</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">}</a>
<a class="sourceLine" id="cb5-7" data-line-number="7"></a>
<a class="sourceLine" id="cb5-8" data-line-number="8"><span class="co">/*</span></a>
<a class="sourceLine" id="cb5-9" data-line-number="9"><span class="co"> * Expanded code</span></a>
<a class="sourceLine" id="cb5-10" data-line-number="10"><span class="co"> */</span></a>
<a class="sourceLine" id="cb5-11" data-line-number="11"><span class="kw">class</span> C {</a>
<a class="sourceLine" id="cb5-12" data-line-number="12">    <span class="kw">private</span> <span class="kw">val</span> <span class="va">prop</span>$delegate = DelegateExpression</a>
<a class="sourceLine" id="cb5-13" data-line-number="13">    <span class="kw">var</span> <span class="va">prop</span>: Type</a>
<a class="sourceLine" id="cb5-14" data-line-number="14">        <span class="kw">get</span>() = prop$delegate.getValue(<span class="kw">this</span>, <span class="kw">this</span>::prop)</a>
<a class="sourceLine" id="cb5-15" data-line-number="15">        <span class="kw">set</span>(value: Type) = prop$delegate.setValue(<span class="kw">this</span>, <span class="kw">this</span>::prop, value)</a>
<a class="sourceLine" id="cb5-16" data-line-number="16">}</a></code></pre></div>
<div class="paragraph">
    <p><span class="sentence">TODO(provideDelegate)</span></p>
</div>
<h4 id="local-property-declaration">Local property declaration</h4>
<div class="paragraph">
    <p><span class="sentence">If a property declaration is local, it creates a local entity which follows most of the same rules as the ones for regular property declarations. </span><span class="sentence">However, local property declarations cannot have custom getters or setters.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">Local property declarations also support <em>destructive</em> declaration in the form of</span></p>
</div>
<div class="sourceCode" id="cb6"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">val</span> (<span class="va">a</span>: T, b: U, c: V, ...) = e</a></code></pre></div>
<div class="paragraph">
    <p><span class="sentence">which is a syntactic sygar for the following expansion</span></p>
</div>
<div class="sourceCode" id="cb7"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">val</span> <span class="va">a</span>: T = e.component1()</a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="kw">val</span> <span class="va">b</span>: U = e.component2()</a>
<a class="sourceLine" id="cb7-3" data-line-number="3"><span class="kw">val</span> <span class="va">c</span>: V = e.component3()</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">...</a></code></pre></div>
<div class="paragraph">
    <p><span class="sentence">where <code>componentN()</code> should be a valid operator function available on the result of <code>e</code>. </span><span class="sentence">Each individual component property follows the rules for regular local property declaration.</span></p>
</div>
<h4 id="getters-and-setters">Getters and setters</h4>
<div class="paragraph">
    <p><span class="sentence">As mentioned before, a property declaration may include a custom getter and/or custom setter (together called <em>accessors</em>) in the form of</span></p>
</div>
<div class="sourceCode" id="cb8"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">var</span> <span class="va">x</span>: T = e</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">    <span class="kw">get</span>(): TG { ... }</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">    <span class="kw">set</span>(anyValidArgumentName: TS) { ... }</a></code></pre></div>
<div class="paragraph">
    <p><span class="sentence">These functions have the following requirements</span></p>
</div>
<ul>
    <li><span class="sentence"><span class="math inline">\(TG \equiv T\)</span></span></li>
    <li><span class="sentence"><span class="math inline">\(TS \equiv T\)</span></span></li>
    <li><div class="paragraph">
        <p><span class="sentence">Both <span class="math inline">\(TG\)</span> and <span class="math inline">\(TG\)</span> types are optional and may be omitted from the declaration</span></p>
    </div></li>
    <li><span class="sentence">Read-only properties may have a custom getter, but not a custom setter</span></li>
    <li><div class="paragraph">
        <p><span class="sentence">Mutable properties may have any combination of a cusom getter and a custom setter</span></p>
    </div></li>
    <li><div class="paragraph">
        <p><span class="sentence">Setter argument may have any valid argument name</span></p>
    </div></li>
</ul>
<blockquote>
    <div class="paragraph">
        <p><span class="sentence">Regular coding convention recommends <code>value</code> as the name for the setter argument</span></p>
    </div>
</blockquote>
<div class="paragraph">
    <p><span class="sentence">One can also ommit the accessor body, in which case a <em>default</em> implementation is used (also known as default accessor).</span></p>
</div>
<div class="sourceCode" id="cb9"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">var</span> <span class="va">x</span>: T = e</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">    <span class="kw">get</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">    <span class="kw">set</span></a></code></pre></div>
<blockquote>
    <div class="paragraph">
        <p><span class="sentence">This notation is usually used if you need to change some aspects of an accessor (i.e., its visibility) without changing the default implementation.</span></p>
    </div>
</blockquote>
<div class="paragraph">
    <p><span class="sentence">Getters and setters allow one to customize how the property is accessed, and may need access to the propertyâ€™s <em>backing field</em>, which is responsible for actually storing the property data. </span><span class="sentence">It is accessed via the special <code>field</code> property available inside accessor body, which follows these conventions</span></p>
</div>
<ul>
    <li><span class="sentence">For a property declaration of type <code>T</code>, field<code>has the same type</code>T`</span></li>
    <li><span class="sentence"><code>field</code> is read-only inside getter body</span></li>
    <li><span class="sentence"><code>field</code> is mutable inside setter body</span></li>
</ul>
<div class="paragraph">
    <p><span class="sentence">However, the backing field is created for a property only in the following cases</span></p>
</div>
<ul>
    <li><span class="sentence">A property has no custom accessors</span></li>
    <li><span class="sentence">A property has a default accessor</span></li>
    <li><span class="sentence">A property has a custom accessor, and it uses <code>field</code> property</span></li>
    <li><span class="sentence">A mutable property has a custom getter or setter, but not both</span></li>
</ul>
<div class="paragraph">
    <p><span class="sentence">In all other cases a property has no backing field.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">Read/write access to the property is replaced with getter/setter invocation respectively.</span></p>
</div>
<h4 id="property-initialization">Property initialization</h4>
<div class="paragraph">
    <p><span class="sentence">All non-abstract properties must be definitely initialized before their first use. </span><span class="sentence">To guarantee this, Kotlin compiler uses a number of analyses which are described in more detail <a href="#control--and-data-flow-analysis">here</a>.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">TODO(Property declaration scope?)</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">TODO(lateinit?)</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">TODO(abstract?)</span></p>
</div>
<h3 id="type-alias">Type alias</h3>
<dl>
    <dt><strong><em>typeAlias</em>:</strong></dt>
    <dd><span class="sentence">[<em>modifierList</em>] <code>typealias</code> {<em>NL</em>} <em>simpleIdentifier</em> [{<em>NL</em>} <em>typeParameters</em>] {<em>NL</em>} <code>=</code> {<em>NL</em>} <em>type</em></span>
    </dd>
</dl>
<div class="paragraph">
    <p><span class="sentence">Type alias introduces an alternative name for the specified type and supports both simple and parameterized types. </span><span class="sentence">If type alias is parameterized, its type parameters must be <a href="#type-parameters">unbounded</a>. </span><span class="sentence">Another restriction is that recursive type aliases are forbidden â€” the type alias name cannot be used in its own right-hand side.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">At the moment, Kotlin supports only top-level type aliases. </span><span class="sentence">The scope where it is accessible is defined by its [<em>visibility modifiers</em>][Visibility].</span></p>
</div>
<h2 id="statements">Statements</h2>
<div class="paragraph">
    <p><span class="sentence">TODO()</span></p>
</div>
<dl>
    <dt><strong><em>statements</em>:</strong></dt>
    <dd><span class="sentence">[<em>statement</em> {semis <em>statement</em>} [<em>semis</em>]]</span>
    </dd>
    <dt><strong><em>statement</em>:</strong></dt>
    <dd><span class="sentence">{<em>labelDefinition</em>}<br />
( <em>declaration</em><br />
| <em>assignment</em><br />
| <em>loopStatement</em><br />
| <em>expression</em>)</span>
    </dd>
</dl>
<div class="paragraph">
    <p><span class="sentence">Unlike some other languages, Kotlin statements include bare expressions and declarations. </span><span class="sentence">This section is focused on those statements that are <em>not</em> expressions or declarations. </span><span class="sentence">For information about expressions and declarations please refer to the corresponding sections of this document.</span></p>
</div>
<h3 id="assignments">Assignments</h3>
<dl>
    <dt><strong><em>assignment</em>:</strong></dt>
    <dd><span class="sentence"><em>directlyAssignableExpression</em> <code>=</code> {<em>NL</em>} <em>expression</em><br />
| <em>assignableExpression</em> <em>assignmentAndOperator</em> {<em>NL</em>} <em>expression</em></span>
    </dd>
    <dt><strong><em>assignmentAndOperator</em>:</strong></dt>
    <dd><span class="sentence"><code>=</code><br />
| <code>+=</code><br />
| <code>-=</code><br />
| <code>*=</code><br />
| <code>/=</code><br />
| <code>%=</code></span>
    </dd>
</dl>
<div class="paragraph">
    <p><span class="sentence">An <em>assignment</em> is a statement that writes a new value to some location, denoted by its left hand side. </span><span class="sentence">Both left-hand and right-hand sides of an assignment are expressions, although there are several restrictions for the expression on the left hand side.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">For an expression to be <em>assignable</em>, i.e.Â be allowed to occur on the left-hand side of an assignment, it <strong>must</strong> be one of the following:</span></p>
</div>
<ul>
    <li><span class="sentence">An identifier referring to a mutable property;</span></li>
    <li><span class="sentence">A navigation expression referring to a mutable property;</span></li>
    <li><span class="sentence">An [indexing expression][Indexing expression], see details below.</span></li>
</ul>
<div class="paragraph">
    <p><span class="sentence">Unlike some other languages, Kotlin assignments <strong>are not</strong> expressions and cannot be used as such.</span></p>
</div>
<h4 id="simple-assignment">Simple assignment</h4>
<div class="paragraph">
    <p><span class="sentence">A <em>simple assigment</em> is the assignment form employing the assign operator <code>=</code>. </span><span class="sentence">If the left-hand side of the assignment refers to a mutable property, a mutation of that property is performed when the assignment is evaluated:</span></p>
</div>
<ul>
    <li><span class="sentence">If the property is [delegated][Property delegation], the corresponding operator function <code>setValue</code> is called using the right-hand side expression value as value argument;</span></li>
    <li><span class="sentence">If the property has a setter, it is called using the right-hand side expression value as value argument;</span></li>
    <li><span class="sentence">If the property is just a variable without delegation or setter, itâ€™s value is directly changed to the value of the right-hand side expression.</span></li>
</ul>
<div class="paragraph">
    <p><span class="sentence">If the left-hand side of the assignment is an indexing expression, the whole statement is treated as an overloaded operator with the following expansion:</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence"><span class="math inline">\(A\)</span><code>[</code><span class="math inline">\(B_1\)</span>,<span class="math inline">\(B_2\)</span>,<span class="math inline">\(B_3\)</span>,â€¦,<span class="math inline">\(B_N\)</span><code>] =</code><span class="math inline">\(C\)</span> is exactly the same as calling <span class="math inline">\(A\)</span><code>.set(</code><span class="math inline">\(B_1\)</span>,<span class="math inline">\(B_2\)</span>,<span class="math inline">\(B_3\)</span>,â€¦,<span class="math inline">\(B_N\)</span>,<span class="math inline">\(C\)</span><code>)</code> where <code>set</code> is a sutable <code>operator</code> function.</span></p>
</div>
<h4 id="operator-assignments">Operator assignments</h4>
<div class="paragraph">
    <p><span class="sentence">An <em>operator assignment</em> is a combined-form assignment that involves one of the following operators: <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>. </span><span class="sentence">All these are overloadable operators with the following expansions:</span></p>
</div>
<ul>
    <li><span class="sentence"><span class="math inline">\(A\)</span><code>+=</code><span class="math inline">\(B\)</span> is exactly the same as one of the following (in this order):</span>
        <ul>
            <li><span class="sentence"><span class="math inline">\(A\)</span><code>.plusAssign(</code><span class="math inline">\(B\)</span><code>)</code> if a corresponding suitable <code>plusAssign</code> operator function exists and is available;</span></li>
            <li><span class="sentence"><span class="math inline">\(A\)</span><code>=</code><span class="math inline">\(A\)</span><code>.plus(</code><span class="math inline">\(B\)</span><code>)</code> if a corresponding suitable <code>plus</code> operator function exists and is available.</span></li>
        </ul></li>
    <li><span class="sentence"><span class="math inline">\(A\)</span><code>-=</code><span class="math inline">\(B\)</span> is exactly the same as one of the following (in this order):</span>
        <ul>
            <li><span class="sentence"><span class="math inline">\(A\)</span><code>.minusAssign(</code><span class="math inline">\(B\)</span><code>)</code> if a corresponding suitable <code>minusAssign</code> operator function exists and is available;</span></li>
            <li><span class="sentence"><span class="math inline">\(A\)</span><code>=</code><span class="math inline">\(A\)</span><code>.minus(</code><span class="math inline">\(B\)</span><code>)</code> if a corresponding suitable <code>minus</code> operator function exists and is available.</span></li>
        </ul></li>
    <li><span class="sentence"><span class="math inline">\(A\)</span><code>*=</code><span class="math inline">\(B\)</span> is exactly the same as one of the following (in this order):</span>
        <ul>
            <li><span class="sentence"><span class="math inline">\(A\)</span><code>.timesAssign(</code><span class="math inline">\(B\)</span><code>)</code> if a corresponding suitable <code>timesAssign</code> operator function exists and is available;</span></li>
            <li><span class="sentence"><span class="math inline">\(A\)</span><code>=</code><span class="math inline">\(A\)</span><code>.times(</code><span class="math inline">\(B\)</span><code>)</code> if a corresponding suitable <code>times</code> operator function exists and is available.</span></li>
        </ul></li>
    <li><span class="sentence"><span class="math inline">\(A\)</span><code>/=</code><span class="math inline">\(B\)</span> is exactly the same as one of the following (in this order):</span>
        <ul>
            <li><span class="sentence"><span class="math inline">\(A\)</span><code>.divAssign(</code><span class="math inline">\(B\)</span><code>)</code> if a corresponding suitable <code>divAssign</code> operator function exists and is available;</span></li>
            <li><span class="sentence"><span class="math inline">\(A\)</span><code>=</code><span class="math inline">\(A\)</span><code>.div(</code><span class="math inline">\(B\)</span><code>)</code> if a corresponding suitable <code>div</code> operator function exists and is available;</span></li>
        </ul></li>
    <li><span class="sentence"><span class="math inline">\(A\)</span><code>%=</code><span class="math inline">\(B\)</span> is exactly the same as one of the following (in this order):</span>
        <ul>
            <li><span class="sentence"><span class="math inline">\(A\)</span><code>.remAssign(</code><span class="math inline">\(B\)</span><code>)</code> if a corresponding suitable <code>remAssign</code> operator function exists and is available;</span></li>
            <li><span class="sentence"><span class="math inline">\(A\)</span><code>=</code><span class="math inline">\(A\)</span><code>.rem(</code><span class="math inline">\(B\)</span><code>)</code> if a corresponding suitable <code>rem</code> operator function exists and is available.</span></li>
        </ul></li>
</ul>
<blockquote>
    <div class="paragraph">
        <p><span class="sentence">As of Kotlin version 1.2.31, there exists an additional overloading function for <code>%</code> called <code>mod</code>, which is deprecated</span></p>
    </div>
</blockquote>
<div class="paragraph">
    <p><span class="sentence">The expanded simple assignment is then proceeded as described in the previous section.</span></p>
</div>
<blockquote>
    <div class="paragraph">
        <p><span class="sentence">Although for most real-world usecases operators <code>++</code> and <code>--</code> are very similar to operator assignments, in Kotlin they are actually expressions and are described as such in the <a href="#expressions">corresponding section</a> of this document.</span></p>
    </div>
</blockquote>
<h3 id="loop-statements">Loop statements</h3>
<div class="paragraph">
    <p><span class="sentence">Loop statements are constructs that repeat evaluating a certain number of statements until a <em>loop exit condition</em> applies.</span></p>
</div>
<dl>
    <dt><strong><em>loopStatement</em>:</strong></dt>
    <dd><span class="sentence"><em>forStatement</em><br />
| <em>whileStatement</em><br />
| <em>doWhileStatement</em></span>
    </dd>
</dl>
<div class="paragraph">
    <p><span class="sentence">Loops are closely related to the semantics of several <a href="#jump-expressions">jump expressions</a>, as these expressions, namely <code>break</code> and <code>continue</code>, are only allowed in the body of a loop. </span><span class="sentence">Please refer to the corresponding section for details.</span></p>
</div>
<h4 id="while-loop">While loop</h4>
<dl>
    <dt><strong><em>whileStatement</em>:</strong></dt>
    <dd><span class="sentence"><code>while</code> {<em>NL</em>} <code>(</code> <em>expression</em> <code>)</code> {<em>NL</em>} <em>controlStructureBody</em><br />
| <code>while</code> {<em>NL</em>} <code>(</code> <em>expression</em> <code>)</code> {<em>NL</em>} <code>;</code></span>
    </dd>
</dl>
<div class="paragraph">
    <p><span class="sentence"><em>While loop statement</em> is very similar to an <a href="#conditional-expression"><code>if</code> expression</a> in the way that it contains a condition expression and a body consisting of one or more statements. </span><span class="sentence">While loop repeats evaluating its body for as long as the condition expression evaluates to true or a <a href="#jump-expressions">jump expression</a> is evaluated to finish the loop.</span></p>
</div>
<blockquote>
    <div class="paragraph">
        <p><span class="sentence">This also means that the condition expression is evaluated before every evaluation of the body, including the first one.</span></p>
    </div>
</blockquote>
<div class="paragraph">
    <p><span class="sentence">As for the <code>if</code> expression, the condition subexpression <strong>must have</strong> type <code>kotlin.Boolean</code>.</span></p>
</div>
<h4 id="do-while-loop">Do-while loop</h4>
<dl>
    <dt><strong><em>doWhileStatement</em>:</strong></dt>
    <dd><span class="sentence"><code>do</code> {<em>NL</em>} [<em>controlStructureBody</em>] {<em>NL</em>} <code>while</code> {<em>NL</em>} <code>(</code> <em>expression</em> <code>)</code></span>
    </dd>
</dl>
<div class="paragraph">
    <p><span class="sentence">A <em>do-while statement</em> is very similar to the while statement, but with a few differences. </span><span class="sentence">First, it has a different syntax. </span><span class="sentence">Second, it evaluates the loop condition expression <strong>after</strong> evaluating the loop body.</span></p>
</div>
<blockquote>
    <div class="paragraph">
        <p><span class="sentence">This also means that the body is always evaluated at least once</span></p>
    </div>
</blockquote>
<div class="paragraph">
    <p><span class="sentence">As for the <code>if</code> expression, the condition subexpression <strong>must have</strong> type <code>kotlin.Boolean</code>.</span></p>
</div>
<h4 id="for-loop">For loop</h4>
<dl>
    <dt><strong><em>forStatement</em>:</strong></dt>
    <dd><span class="sentence"><code>for</code> {<em>NL</em>} <code>(</code> {<em>annotation</em>} (variableDeclaration | <em>multiVariableDeclaration</em>) <code>in</code> <em>expression</em> <code>)</code> {<em>NL</em>} [<em>controlStructureBody</em>]</span>
    </dd>
</dl>
<blockquote>
    <div class="paragraph">
        <p><span class="sentence">Unlike other languages, Kotlin does not have a free-form condition-based for loops. </span><span class="sentence">The only form of for-loop available in Kotlin is (what itâ€™s called in other languages) â€œthe foreach loopâ€, iterating over arrays and other datastructures</span></p>
    </div>
</blockquote>
<div class="paragraph">
    <p><span class="sentence">A <em>for statement</em> is a special kind of loop statements that is used to iterate over data structures containing a number of elements. </span><span class="sentence">The for loop consists of a loop body, a <strong>container expression</strong> and the <strong>iteration variable declaration</strong>.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">The for loop is actually an [overloadable][Overloadable operators] syntax form with the following expansion:</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence"><code>for(</code><span class="math inline">\(VarDecl\)</span><code>) in</code><span class="math inline">\(C\)</span><code>) $Body$</code> is exactly the same as</span></p>
</div>
<div class="sourceCode" id="cb10"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">val</span> <span class="va">__iterator</span> = C.iterator()</a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="cf">while</span>(__iterator.hasNext()) {</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">    VarDecl = __iterator.next()</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">    &lt;... all the statements from Body&gt;</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">}</a></code></pre></div>
<div class="paragraph">
    <p><span class="sentence">where <code>iterator</code>, <code>hasNext</code>, <code>next</code> are all acceptable operator functions available in the current scope.</span></p>
</div>
<blockquote>
    <div class="paragraph">
        <p><span class="sentence">Please note that expansions are hygenic, meaning the generated iterator variable never clashes with any other values in the program and cannot be accessed outside the expansion</span></p>
    </div>
</blockquote>
<h3 id="code-blocks">Code blocks</h3>
<dl>
    <dt><strong><em>block</em>:</strong></dt>
    <dd><span class="sentence"><code>{</code> {<em>NL</em>} <em>statements</em> {<em>NL</em>} <code>}</code></span>
    </dd>
    <dt><strong><em>statements</em>:</strong></dt>
    <dd><span class="sentence">[<em>statement</em> {semis <em>statement</em>} [<em>semis</em>]]</span>
    </dd>
</dl>
<div class="paragraph">
    <p><span class="sentence">A <em>code block</em> is a series of statements between curly braces separated by newlines or/and semicolons. </span><span class="sentence">A code block may be empty. </span><span class="sentence">Evaluating a code block means evaluating all its statements in the order they are given inside it.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">The <em>last expression</em> of a code block is the last statement in the block (if any) if and only if this statement is also an expression. </span><span class="sentence">The last expressions are important when defining functions and control structure expressions.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">The code block is said to contain no last expression if it does not contain any statements of the last statement is not an expression (e.g.Â it is an assignment, a loop or a declaration).</span></p>
</div>
<blockquote>
    <div class="paragraph">
        <p><span class="sentence">This usually means that a synthetic last expression with no runtime semantics and with type <code>kotlin.Unit</code> is introduced instead</span></p>
    </div>
</blockquote>
<div class="paragraph">
    <p><span class="sentence">A <em>control structure body</em> is either a single statement or a code block. </span><span class="sentence">The <em>last expression</em> of a control structure body is either the last expression of the code block (if it is a code block) or the single statement itself if it is an expression. </span><span class="sentence">If the control structure body is not a code block or an expression, it has no last expression.</span></p>
</div>
<blockquote>
    <div class="paragraph">
        <p><span class="sentence">This is usually equivalent to wrapping the single statement in a new synthetic code block</span></p>
    </div>
</blockquote>
<div class="paragraph">
    <p><span class="sentence">In some contexts, a control structure body is expected to have a value and/or a type. </span><span class="sentence">The value of a control structure body is:</span></p>
</div>
<ul>
    <li><span class="sentence">The value of its last expression if it exists;</span></li>
    <li><span class="sentence">The singleton <code>kotlin.Unit</code> object otherwise.</span></li>
</ul>
<div class="paragraph">
    <p><span class="sentence">The <em>type of a control structure body</em> is the type of its value.</span></p>
</div>
<h3 id="todo">TODO</h3>
<ul>
    <li><span class="sentence">Are declarations statements or not?</span>
        <ul>
            <li><span class="sentence">In the current grammar, they are</span></li>
        </ul></li>
    <li><span class="sentence">Wording</span></li>
    <li><span class="sentence">Mutable vs immutable properties</span></li>
    <li><span class="sentence">How expansions with new variables actually work</span></li>
</ul>
<h2 id="expressions">Expressions</h2>
<div class="paragraph">
    <p><span class="sentence">TODO()</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">An expression may be <em>used as a statement</em> or <em>used as an expression</em> depending on the context. </span><span class="sentence">As all expressions are valid statements <a href="#statements">see the statements section</a>, free expressions may be used as single statements or inside code blocks.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">An expression is used as an expression if it is encountered at any position where a statement is not allowed, for example, as an operand to an operator or as an immediate argument for a function call. </span><span class="sentence">An expression is used as a statement if it is encountered at any position where a statement is allowed.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">Some expressions are only allowed to be used as statements unless certain restrictions are met and this may affect the semantics, the compile-type type information and the safety of these expressions. </span><span class="sentence">All expressions are allowed to be used as statements.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">TODO()</span></p>
</div>
<h3 id="constant-literals">Constant literals</h3>
<div class="paragraph">
    <p><span class="sentence">Constant literals are expressions that correspond to constant, non-changing values. </span><span class="sentence">Every constant literal is defined to have a single standard library type, whichever it is defined to be on current platform.</span></p>
</div>
<h4 id="boolean-literals">Boolean literals</h4>
<dl>
    <dt><strong><em>BooleanLiteral</em>:</strong></dt>
    <dd><span class="sentence"><code>true</code> | <code>false</code></span>
    </dd>
</dl>
<div class="paragraph">
    <p><span class="sentence">Keywords <code>true</code> and <code>false</code> denote boolean literals of corresponding values. </span><span class="sentence">These are two strong keywords and as such cannot be used as identifiers unless [escaped][Escaped identifiers]. </span><span class="sentence">Values <code>true</code> and <code>false</code> always have type <code>kotlin.Bool</code>.</span></p>
</div>
<h4 id="integer-literals">Integer literals</h4>
<dl>
    <dt><strong><em>IntegerLiteral</em>:</strong></dt>
    <dd><span class="sentence"><em>DecDigitNoZero</em> {<em>DecDigitOrSeparator</em>} <em>DecDigit</em> | <em>DecDigit</em></span>
    </dd>
    <dt><strong><em>HexLiteral</em>:</strong></dt>
    <dd><span class="sentence"><code>0</code> (<code>x</code>|<code>X</code>) <em>HexDigit</em> {<em>HexDigitOrSeparator</em>} <em>HexDigit</em><br />
| <code>0</code> (<code>x</code>|<code>X</code>) <em>HexDigit</em></span>
    </dd>
    <dt><strong><em>BinLiteral</em>:</strong></dt>
    <dd><span class="sentence"><code>0</code> (<code>b</code>|<code>B</code>) <em>BinDigit</em> {<em>BinDigitOrSeparator</em>} <em>BinDigit</em><br />
| <code>0</code> (<code>b</code>|<code>B</code>) <em>BinDigit</em></span>
    </dd>
    <dt><strong><em>DecDigitNoZero</em>:</strong></dt>
    <dd><span class="sentence"><em>DecDigit</em> - <code>0</code></span>
    </dd>
    <dt><strong><em>DecDigitOrSeparator</em>:</strong></dt>
    <dd><span class="sentence"><em>DecDigit</em> | <em>Underscore</em></span>
    </dd>
    <dt><strong><em>HexDigitOrSeparator</em>:</strong></dt>
    <dd><span class="sentence"><em>HexDigit</em> | <em>Underscore</em></span>
    </dd>
    <dt><strong><em>BinDigitOrSeparator</em>:</strong></dt>
    <dd><span class="sentence"><em>BinDigit</em> | <em>Underscore</em></span>
    </dd>
    <dt><strong><em>DecDigits</em>:</strong></dt>
    <dd><span class="sentence"><em>DecDigit</em> {<em>DecDigitOrSeparator</em>} <em>DecDigit</em> | <em>DecDigit</em></span>
    </dd>
</dl>
<h5 id="decimal-integer-literals">Decimal integer literals</h5>
<div class="paragraph">
    <p><span class="sentence">A sequence of decimal digit symbols (<code>0</code> though <code>9</code>) is a decimal integer literal. </span><span class="sentence">Digits may be separated by the underscore symbol, but no underscore can be placed before the first digit or after the last one. </span><span class="sentence">Please note that unlike other languages Kotlin does not support octal literals. </span><span class="sentence">Even more, any decimal literal starting with digit <code>0</code> and containing more than 1 digit is not a valid decimal literal.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">Decimal literals may be suffixed by the long literal mark (<code>L</code> symbol). </span><span class="sentence">A decimal literal with the mark has type <code>kotlin.Long</code>, while a literal without it has type <code>kotlin.Int</code> if its value is below <span class="math inline">\(2^{31}-1\)</span> or type <code>kotlin.Long</code> otherwise.</span></p>
</div>
<h5 id="hexadecimal-integer-literals">Hexadecimal integer literals</h5>
<div class="paragraph">
    <p><span class="sentence">A sequence of hexadecimal digit symbols (<code>0</code> through <code>9</code>, <code>a</code> through <code>f</code>, or <code>A</code> through <code>F</code>) prefixed by <code>0x</code> or <code>0X</code> is a hexadecimal integer literal. </span><span class="sentence">Digits may be separated by the underscore symbol, but no underscore can be placed before the first digit or after the last one.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">Hexadecimal literals may be suffixed by the long literal mark (<code>L</code> symbol). </span><span class="sentence">A hexadecimal literal with the mark has type <code>kotlin.Long</code>, while a literal without it has type <code>kotlin.Int</code> if its value is below <span class="math inline">\(2^{31}-1\)</span> or type <code>kotlin.Long</code> otherwise.</span></p>
</div>
<h5 id="binary-integer-literals">Binary integer literals</h5>
<div class="paragraph">
    <p><span class="sentence">A sequence of binary digit symbols (<code>0</code> or <code>1</code>) prefixed by <code>0b</code> or <code>0B</code> is a binary integer literal. </span><span class="sentence">Digits may be separated by the underscore symbol, but no underscore can be placed before the first digit or after the last one.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">Binary literals may be suffixed by the long literal mark (<code>L</code> symbol). </span><span class="sentence">A binary literal with the mark has type <code>kotlin.Long</code>, while a literal without it has type <code>kotlin.Int</code> if its value is below <span class="math inline">\(2^{31}-1\)</span> or type <code>kotlin.Long</code> otherwise.</span></p>
</div>
<h4 id="real-literals">Real literals</h4>
<dl>
    <dt><strong><em>RealLiteral</em>:</strong></dt>
    <dd><span class="sentence"><em>FloatLiteral</em> | <em>DoubleLiteral</em></span>
    </dd>
    <dt><strong><em>FloatLiteral</em>:</strong></dt>
    <dd><span class="sentence"><em>DoubleLiteral</em> (<code>f</code> | <code>F</code>) | <em>DecDigits</em> (<code>f</code> | <code>F</code>)</span>
    </dd>
    <dt><strong><em>DoubleLiteral</em>:</strong></dt>
    <dd><span class="sentence">[<em>DecDigits</em>] <code>.</code> <em>DecDigits</em> [<em>DoubleExponent</em>] | <em>DecDigits</em> <em>DoubleExponent</em></span>
    </dd>
</dl>
<div class="paragraph">
    <p><span class="sentence">A <em>real literal</em> consists of the following parts: the whole-number part, a decimal point (represented by the ASCII period character (<code>.</code>)), a fraction part and an exponent. </span><span class="sentence">Unlike other languages, Kotlin real literals may only be expressed in decimal numbers. </span><span class="sentence">The number also may be followed by type suffix (<code>f</code> or <code>F</code>).</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">The exponent is an exponent mark (<code>e</code> or <code>E</code>) followed by an optionaly signed decimal integer (a sequence of decimal digits).</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">The whole-number part and the exponent part may be omitted. </span><span class="sentence">The fraction part may only be omitted together with the decimal point if the whole part and either the exponent part or type suffix are present. </span><span class="sentence">Unlike other languages, Kotlin does not support omitting the fraction part, but leaving the decimal point in.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">The digits of the whole-number part or the fraction part or the exponent may be optionally separated by underscores, but an underscore may not be placed between, before, or after these parts. </span><span class="sentence">It also may not be placed before or after the exponent sign symbol.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">A real literal without a type suffix has type <code>kotlin.Double</code>, while a real literal with the type suffix does have type <code>kotlin.Float</code>. </span><span class="sentence">There is no special suffix attributed to the <code>kotlin.Double</code> type.</span></p>
</div>
<h4 id="character-literals">Character literals</h4>
<dl>
    <dt><strong><em>CharacterLiteral</em>:</strong></dt>
    <dd><span class="sentence"><code>'</code> (<em>EscapeSeq</em> | <em>&lt;any character except CR, LF, <code>'</code> and <code>\</code>&gt;</em>) <code>'</code></span>
    </dd>
    <dt><strong><em>EscapeSeq</em>:</strong></dt>
    <dd><span class="sentence"><em>UnicodeCharacterLiteral</em> | <em>EscapedCharacter</em></span>
    </dd>
    <dt><strong><em>UnicodeCharacterLiteral</em>:</strong></dt>
    <dd><span class="sentence"><code>\</code> <code>u</code> <em>HexDigit</em> <em>HexDigit</em> <em>HexDigit</em> <em>HexDigit</em></span>
    </dd>
    <dt><strong><em>EscapedCharacter</em>:</strong></dt>
    <dd><span class="sentence"><code>\</code> (<code>t</code> | <code>b</code> | <code>r</code> | <code>n</code> | <code>'</code> | <code>&quot;</code> | <code>\</code> | <code>$</code>)</span>
    </dd>
</dl>
<div class="paragraph">
    <p><span class="sentence">A <strong>character literal</strong> defines a constant holding a unicode character value. </span><span class="sentence">A simply-formed character literal is any symbol between two single quotation mark symbols (ASCII single quotation <code>'</code>), excluding newline symbols (<em>CR</em> and <em>LF</em>), the single quotation symbol itself and the escaping mark (the ASCII backslash symbol <code>\</code>).</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">A character literal may also contain an escaped symbol of two kinds: a simple escaped symbol or a unicode codepoint. </span><span class="sentence">Simple escaped symbols include:</span></p>
</div>
<ul>
    <li><span class="sentence"><code>\t</code> â€” the unicode TAB symbol (TODO());</span></li>
    <li><span class="sentence"><code>\b</code> â€” the unicode BACKSPACE symbol(TODO());</span></li>
    <li><span class="sentence"><code>\r</code> â€” <em>CR</em>;</span></li>
    <li><span class="sentence"><code>\n</code> â€” <em>LF</em>;</span></li>
    <li><span class="sentence"><code>\'</code> â€” the unicode single quotation symbol(TODO());</span></li>
    <li><span class="sentence"><code>\&quot;</code> â€” the unicode double quotation symbol(TODO());</span></li>
    <li><span class="sentence"><code>\\</code> â€” the unicode backslash symbol symbol(TODO());</span></li>
    <li><span class="sentence"><code>\$</code> â€” the unicode DOLLAR symbol.</span></li>
</ul>
<div class="paragraph">
    <p><span class="sentence">A unicode codepoint escape sequence is the symbols <code>\u</code> followed by exactly four hexadecimal digits. </span><span class="sentence">It represents the unicode symbol with the codepoint equal to the number represented by these digits. </span><span class="sentence">Please note that unicode escapes support only unicode symbols in range U+0000 to U+FFFF.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">Any character literal has type <code>kotlin.Char</code>.</span></p>
</div>
<h4 id="string-literals-1">String literals</h4>
<div class="paragraph">
    <p><span class="sentence">Kotlin supports [string interpolation][String Interpolation] mechanisms that supersede traditional string literals. </span><span class="sentence">Please refer to the corresponding section.</span></p>
</div>
<h4 id="null-literal">Null literal</h4>
<div class="paragraph">
    <p><span class="sentence">The keyword <code>null</code> signifies the <strong>null reference</strong>, which is a valid value for all <a href="#nullable-types">nullable types</a>. </span><span class="sentence">Null reference implicitly has the nullable <code>kotlin.Nothing?</code> type and is, by definition, the only valid value for this type (see <a href="#kotlin.nothing">the corresponding section</a>).</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">TODO(): reshuffle these sections</span></p>
</div>
<h3 id="try-expression">Try-expression</h3>
<dl>
    <dt><strong><em>tryExpression</em>:</strong></dt>
    <dd><span class="sentence"><code>try</code> {<em>NL</em>} <em>block</em> {{<em>NL</em>} <em>catchBlock</em>} [{<em>NL</em>} <em>finallyBlock</em>]</span>
    </dd>
    <dt><strong><em>catchBlock</em>:</strong></dt>
    <dd><span class="sentence"><code>catch</code> {<em>NL</em>} <code>(</code> {<em>annotation</em>} <em>simpleIdentifier</em> <code>:</code> <em>userType</em> <code>)</code> {<em>NL</em>} <em>block</em></span>
    </dd>
    <dt><strong><em>finallyBlock</em>:</strong></dt>
    <dd><span class="sentence"><code>finally</code> {<em>NL</em>} <em>block</em></span>
    </dd>
</dl>
<div class="paragraph">
    <p><span class="sentence">A <em>try-expression</em> is an expression starting with the keyword <code>try</code>. </span><span class="sentence">It consists of a code block (<em>try body</em>) and several optional additional blocks: one of more <em>catch blocks</em>, starting with the soft keyword <code>catch</code> with a single parameter called <em>exception parameter</em> followed by another code block and a single optional <em>finally block</em>, starting with the soft keyword <code>finally</code> and yet another code block. </span><span class="sentence">At least one catch or finally block must exist, otherwise the expression is ill-formed.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">The try-expression evaluates its body as normally, but if any statement in the body throws an exception, the exception, rather than being propagated up the call stack, gets checked for its type. </span><span class="sentence">If there exists any catch block which parameter type is valid for the checked exception, this catch block is evaluated immediately after the exception is thrown and the exception itself is passed inside the catch block as the corresponding parameter. </span><span class="sentence">If there are several catch blocks with suitable parameter types, the first one is picked.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">If there is a finally block, it gets evaluated after any evaluated catch block, or, if no catch block was encountered, after the exception was thrown. </span><span class="sentence">If no catch block was selected, the exception is [propagated as usual][Exceptions] up the call stack after the finally block (if any) is evaluated. </span><span class="sentence">If no exception is thrown during the evaluation of the try body, no catch blocks are checked, but the finally block is executed anyway and program execution continues as normal.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">The value of the try-expression is the same as the value of the last expression of the try body (if no exception was thrown) or the value of the last expression of the selected catch block (if one was selected). </span><span class="sentence">All other situations mean that an exception is propagated up the call stack, so the value of the try-expression becomes irrelevant. </span><span class="sentence">The finally block does get executed as described above, but has no effect on the value returned by the try-expression.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">The type of the try-expression is the [least upper bound][Least upper bound] of the types of the last expressions of the try body and the last expressions of all the catch blocks (TODO(): not that simple). </span><span class="sentence">If any of the blocks have no valid last expression, the type is inferred to be <code>kotlin.Unit</code>, but the try-expression may be used as an expression anyway.</span></p>
</div>
<h3 id="conditional-expression">Conditional expression</h3>
<dl>
    <dt><strong><em>ifExpression</em>:</strong></dt>
    <dd><span class="sentence"><code>if</code> {<em>NL</em>} <code>(</code> {<em>NL</em>} <em>expression</em> {<em>NL</em>} <code>)</code> {<em>NL</em>} <em>controlStructureBody</em> [[<code>;</code>] {<em>NL</em>} <code>else</code> {<em>NL</em>} <em>controlStructureBody</em>]<br />
| <code>if</code> {<em>NL</em>} <code>(</code> {<em>NL</em>} <em>expression</em> {<em>NL</em>} <code>)</code> {<em>NL</em>} [<code>;</code> {<em>NL</em>}] <code>else</code> {<em>NL</em>} <em>controlStructureBody</em></span>
    </dd>
</dl>
<div class="paragraph">
    <p><span class="sentence"><strong>Conditional expressions</strong> use the boolean value of one expression (<em>condition</em>) to decide which of two control structure bodies (<em>branches</em>) should be evaluated. </span><span class="sentence">If the condition evaluates to <code>true</code>, than the first branch (the true branch) is evaluated, otherwise the second branch is. </span><span class="sentence">The value of the resulting expression is the same as the value of the chosen branch. </span><span class="sentence">The type of the resulting expression is the [least upper bound][Least upper bound] of the types of two branches (TODO(): not that simple). </span><span class="sentence">If one of the branches is omitted (see the grammar entry above), the resulting expression has type <a href="#kotlin.unit"><code>kotlin.Unit</code></a> and the whole construct may not be used as an expression, but only as a statement.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">The condition expression must have type <code>kotlin.Boolean</code> (TODO(): or be smartcasted to it!), otherwise it is a type error.</span></p>
</div>
<blockquote>
    <div class="paragraph">
        <p><span class="sentence">When used as expressions, conditional expressions are special in the sense of operator precedence: they have the highest (same as all primary expressions) priority when placed on the right side of any binary expression, but when placed on the left side, they have the lowest priority. </span><span class="sentence">For details, see the <a href="#syntax-grammar">grammar</a></span></p>
    </div>
</blockquote>
<h3 id="when-expression">When expression</h3>
<dl>
    <dt><strong><em>whenExpression</em>:</strong></dt>
    <dd><span class="sentence"><code>when</code> {<em>NL</em>} [<code>(</code> <em>expression</em> <code>)</code>] {<em>NL</em>} <code>{</code> {<em>NL</em>} {<em>whenEntry</em> {<em>NL</em>}} {<em>NL</em>} <code>}</code></span>
    </dd>
    <dt><strong><em>whenEntry</em>:</strong></dt>
    <dd><span class="sentence"><em>whenCondition</em> {{<em>NL</em>} <code>,</code> {<em>NL</em>} <em>whenCondition</em>} {<em>NL</em>} <code>-&gt;</code> {<em>NL</em>} <em>controlStructureBody</em> [<em>semi</em>]<br />
| <code>else</code> {<em>NL</em>} <code>-&gt;</code> {<em>NL</em>} <em>controlStructureBody</em> [<em>semi</em>]</span>
    </dd>
    <dt><strong><em>whenCondition</em>:</strong></dt>
    <dd><span class="sentence"><em>expression</em><br />
| <em>rangeTest</em><br />
| <em>typeTest</em></span>
    </dd>
    <dt><strong><em>rangeTest</em>:</strong></dt>
    <dd><span class="sentence"><em>inOperator</em> {<em>NL</em>} <em>expression</em></span>
    </dd>
    <dt><strong><em>typeTest</em>:</strong></dt>
    <dd><span class="sentence"><em>isOperator</em> {<em>NL</em>} <em>type</em></span>
    </dd>
</dl>
<div class="paragraph">
    <p><span class="sentence"><strong>When expression</strong> is alike a <strong>conditional expression</strong> in the sense that it allows several different control structure bodies (<em>cases</em>) to be evaluated depending on boolean conditions. </span><span class="sentence">The key difference, however, is that when expressions may include several different conditions. </span><span class="sentence">When expression has two different forms: with bound value and without it.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence"><strong>When expression without bound value</strong> (the form where the expression enclosed in parantheses is absent) evaluates one of the many different expressions based on corresponding conditions present in the same <em>when entry</em>. </span><span class="sentence">Each entry consists of a boolean <em>condition</em> (or a special <code>else</code> condition), each of which is checked and evaluated in order of appearance. </span><span class="sentence">If the current condition evaluates to <code>true</code>, the corresponding expression is evaluated and the value of when expression is the same as the evaluated expression. </span><span class="sentence">All remaining conditions and expressions are not evaluated. </span><span class="sentence">The <code>else</code> branch is a special branch that evaluates if none of the branches above it evaluated to <code>true</code>.</span></p>
</div>
<blockquote>
    <div class="paragraph">
        <p><span class="sentence">Informally speaking, you can always replace the <code>else</code> branch with literal <code>true</code> and the semantics of the entry would not change</span></p>
    </div>
</blockquote>
<div class="paragraph">
    <p><span class="sentence">The <code>else</code> entry is also special in the sense that it <strong>must</strong> be the last entry in the expression, otherwise a compiler error must be generated.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence"><strong>When expression with bound value</strong> (the form where the expression enclosed in parantheses is present) are very similar to the form without bound value, but use different syntax for conditions. </span><span class="sentence">In fact, it supports three different condition forms:</span></p>
</div>
<ul>
    <li><span class="sentence"><em>Type test condition</em>: type checking operator [TODO: link] followed by type. </span><span class="sentence">The condition generated is a type check expression [TODO: link] with the same operator and the same type, but an implicit left hand side, which has the same value as the bound expression.</span></li>
    <li><span class="sentence"><em>Contains test condition</em>: containment operator [TODO: link] followed by an expression. </span><span class="sentence">The condition generated is a containment check expression [TODO: link] with the same operator and the same right hand side expression, but an implicit left hand side, which has the same value as the bound expression.</span></li>
    <li><span class="sentence"><em>Any other expression</em>. </span><span class="sentence">The condition generated is an equality operator [TODO: link], with the left hand side being the bound expression, and the right hand side being the expression placed inside the entry.</span></li>
    <li><span class="sentence">The <code>else</code> condition, which works the exact same way as it would in the form without bound expression.</span></li>
</ul>
<blockquote>
    <div class="paragraph">
        <p><span class="sentence">This also means that if this form of <code>when</code> contains a boolean expression, it is not checked directly as if it would be in the other form, but rather checked for <strong>equality</strong> with the bound variable, which is not the same thing.</span></p>
    </div>
</blockquote>
<div class="paragraph">
    <p><span class="sentence">The type of the resulting expression is the [least upper bound][Least upper bound] of the types of all the entries (TODO(): not that simple). </span><span class="sentence">If the expression is not <a href="#exhaustive-when-expressions">exhaustive</a>, it has type <a href="#kotlin.unit"><code>kotlin.Unit</code></a> and the whole construct may not be used as an expression, but only as a statement.</span></p>
</div>
<h4 id="exhaustive-when-expressions">Exhaustive when expressions</h4>
<div class="paragraph">
    <p><span class="sentence">A when expression is called <strong><em>exhaustive</em></strong> if at least one of the following is true:</span></p>
</div>
<ul>
    <li><span class="sentence">It has an <code>else</code> entry;</span></li>
    <li><span class="sentence">It has a bound value and at least one of the following holds:</span>
        <ul>
            <li><span class="sentence">The bound expression is of type <code>kotlin.Boolean</code> and the conditions contain both:</span>
                <ul>
                    <li><span class="sentence">A [constant expression][Constant expressions] evaluating to value <code>true</code>;</span></li>
                    <li><span class="sentence">A [constant expression][Constant expressions] evaluating to value <code>false</code>;</span></li>
                </ul></li>
            <li><span class="sentence">The bound expression is of a [<code>sealed class</code>][Sealed classes] type and all its possible subtypes are covered using type test conditions of this expression;</span></li>
            <li><span class="sentence">The bound expression is of an [<code>enum class</code>][Enum classes] type and all enumerated values are checked for equality using constant conditions;</span></li>
            <li><span class="sentence">The bound expression is of a nullable type and one of the cases above is met for its non-nullable counterpart and, in addition, there is a condition containing literal <code>null</code>.</span></li>
        </ul></li>
</ul>
<h3 id="logical-disjunction-expression">Logical disjunction expression</h3>
<dl>
    <dt><strong><em>disjunction</em>:</strong></dt>
    <dd><span class="sentence"><em>conjunction</em> {{<em>NL</em>} <code>||</code> {<em>NL</em>} (<em>conjunction</em> | <em>ifExpression</em>)}</span>
    </dd>
</dl>
<div class="paragraph">
    <p><span class="sentence">Operator symbol <code>||</code> performs logical disjunction over two values of type <code>kotlin.Boolean</code>. </span><span class="sentence">Note that this operator is <strong>lazy</strong>, meaning that it does not evaluate the right hand side argument unless the left hand side argument evaluated to <code>false</code>.</span></p>
</div>
<h3 id="logical-conjunction-expression">Logical conjunction expression</h3>
<dl>
    <dt><strong><em>conjunction</em>:</strong></dt>
    <dd><span class="sentence"><em>equality</em> {{<em>NL</em>} <code>&amp;&amp;</code> {<em>NL</em>} (<em>equality</em> | <em>ifExpression</em>)}</span>
    </dd>
</dl>
<div class="paragraph">
    <p><span class="sentence">Operator symbol <code>&amp;&amp;</code> performs logical conjunction over two values of type <code>kotlin.Boolean</code>. </span><span class="sentence">Note that this operator is <strong>lazy</strong>, meaning that it does not evaluate the right hand side argument unless the left hand side argument evaluated to <code>true</code>.</span></p>
</div>
<h3 id="equality-expressions">Equality expressions</h3>
<dl>
    <dt><strong><em>equality</em>:</strong></dt>
    <dd><span class="sentence"><em>comparison</em> {<em>equalityOperator</em> {<em>NL</em>} (<em>comparison</em> | <em>ifExpression</em>)}</span>
    </dd>
    <dt><strong><em>equalityOperator</em>:</strong></dt>
    <dd><span class="sentence"><code>!=</code><br />
| <code>!==</code><br />
| <code>==</code><br />
| <code>===</code></span>
    </dd>
</dl>
<div class="paragraph">
    <p><span class="sentence">Equality expressions are binary expressions involving equality operators. </span><span class="sentence">There are two kinds of equality operators: <em>reference equality operators</em> and <em>value equality operators</em>.</span></p>
</div>
<h4 id="reference-equality-expressions">Reference equality expressions</h4>
<div class="paragraph">
    <p><span class="sentence"><em>Reference equality expressions</em> are binary expressions employing reference equality operators: <code>===</code> and <code>!==</code>. </span><span class="sentence">These expressions check if two values are equal <em>by reference</em>, meaning that two values are equal (non-equal for operator <code>!==</code>) if and only if they represent the same runtime value created using the same constructor call.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">For values created without construction calls, notably the constant literals and constant expressions composed of those literals, the following holds:</span></p>
</div>
<ul>
    <li><span class="sentence">If these values are <a href="#value-equality-expressions">non-equal by value</a>, they are also non-equal by reference;</span></li>
    <li><span class="sentence">Any instance of the null reference <code>null</code> is reference-equals to any other instance of the null reference;</span></li>
    <li><span class="sentence">Otherwise, it is implementation-defined and must not be used as a means of comparing two such values.</span></li>
</ul>
<div class="paragraph">
    <p><span class="sentence">Reference equality expressions always have type <code>kotlin.Boolean</code>.</span></p>
</div>
<h4 id="value-equality-expressions">Value equality expressions</h4>
<div class="paragraph">
    <p><span class="sentence"><em>Value equality expressions</em> are binary expressions employing value equality operators: <code>==</code> and <code>!=</code>. </span><span class="sentence">These operators are [overloadable][Overloadable operators] with the following expansion:</span></p>
</div>
<ul>
    <li><span class="sentence"><span class="math inline">\(A\)</span> <code>==</code> <span class="math inline">\(B\)</span> is exactly the same as <span class="math inline">\(A\)</span><code>?.equals(</code><span class="math inline">\(B\)</span><code>) ?: (</code><span class="math inline">\(B\)</span><code>=== null)</code> where <code>equals</code> is a valid operator function available in the current scope;</span></li>
    <li><span class="sentence"><span class="math inline">\(A\)</span> <code>!=</code> <span class="math inline">\(B\)</span> is exactly the same as <code>!(</code><span class="math inline">\(A\)</span><code>?.equals(</code><span class="math inline">\(B\)</span><code>) ?: (</code><span class="math inline">\(B\)</span><code>=== null))</code> where <code>equals</code> is a valid operator function available in the current scope.</span></li>
</ul>
<blockquote>
    <div class="paragraph">
        <p><span class="sentence">Please note that the class <code>kotlin.Any</code> has a built-in open operator member function called <code>equals</code>, meaning that there is always at least one available overloading candidate for any value equality expression.</span></p>
    </div>
</blockquote>
<div class="paragraph">
    <p><span class="sentence">Value equality expressions always have type <code>kotlin.Boolean</code>. </span><span class="sentence">If the corresponding operator function has a different return type, it is invalid and a compiler error should be generated.</span></p>
</div>
<h3 id="comparison-expressions">Comparison expressions</h3>
<dl>
    <dt><strong><em>comparison</em>:</strong></dt>
    <dd><span class="sentence"><em>infixOperation</em> [<em>comparisonOperator</em> {<em>NL</em>} (<em>infixOperation</em> | <em>ifExpression</em>)]</span>
    </dd>
    <dt><strong><em>comparisonOperator</em>:</strong></dt>
    <dd><span class="sentence"><code>&lt;</code><br />
| <code>&gt;</code><br />
| <code>&lt;=</code><br />
| <code>&gt;=</code></span>
    </dd>
</dl>
<div class="paragraph">
    <p><span class="sentence"><em>Comparison expressions</em> are binary expressions employing the comparison operators: <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code> and <code>&gt;=</code>. </span><span class="sentence">These operators are [overloadable][Overloadable operators] with the following expansion:</span></p>
</div>
<ul>
    <li><span class="sentence"><span class="math inline">\(A\)</span><code>&lt;</code><span class="math inline">\(B\)</span> is exactly the same as <span class="math inline">\(A\)</span><code>.compareTo(</code><span class="math inline">\(B\)</span><code>) [&lt;] 0</code></span></li>
    <li><span class="sentence"><span class="math inline">\(A\)</span><code>&gt;</code><span class="math inline">\(B\)</span> is exactly the same as <code>0 [&lt;]</code><span class="math inline">\(A\)</span><code>.compareTo(</code><span class="math inline">\(B\)</span><code>)</code></span></li>
    <li><span class="sentence"><span class="math inline">\(A\)</span><code>&lt;=</code><span class="math inline">\(B\)</span> is exactly the same as <code>!(</code><span class="math inline">\(A\)</span><code>.compareTo(</code><span class="math inline">\(B\)</span><code>) [&lt;] 0)</code></span></li>
    <li><span class="sentence"><span class="math inline">\(A\)</span><code>&gt;=</code><span class="math inline">\(B\)</span> is exactly the same as <code>!(0 [&lt;]</code><span class="math inline">\(A\)</span><code>.compareTo(</code><span class="math inline">\(B\)</span><code>))</code></span></li>
</ul>
<div class="paragraph">
    <p><span class="sentence">where <code>compareTo</code> is a valid operator function available in the current scope and <code>[&lt;]</code> (read â€œboxed lessâ€) is a special operator unavailable for in-code use in Kotlin and performing integer â€œless-thanâ€ comparison of two integer numbers. </span><span class="sentence">The <code>compareTo</code> overloaded function must have return type <code>kotlin.Int</code>, otherwise itâ€™s a compiler error.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">All comparison expressions always have type <code>kotlin.Boolean</code>.</span></p>
</div>
<h3 id="type-checking-and-containment-checking-expressions">Type-checking and containment-checking expressions</h3>
<dl>
    <dt><strong><em>infixOperation</em>:</strong></dt>
    <dd><span class="sentence"><em>elvisExpression</em> {<em>inOperator</em> {<em>NL</em>} (<em>elvisExpression</em> | <em>ifExpression</em>) | <em>isOperator</em> {<em>NL</em>} <em>type</em>}</span>
    </dd>
    <dt><strong><em>inOperator</em>:</strong></dt>
    <dd><span class="sentence"><code>in</code> | <code>!in</code></span>
    </dd>
    <dt><strong><em>isOperator</em>:</strong></dt>
    <dd><span class="sentence"><code>is</code> | <code>!is</code></span>
    </dd>
</dl>
<h4 id="type-checking-expression">Type-checking expression</h4>
<div class="paragraph">
    <p><span class="sentence">A type checking expression employs the use of an type-checking operators <code>is</code> or <code>!is</code> and has an expression as a left-hand side operand and a type name as a right-hand side operand. </span><span class="sentence">The type must be [runtime-available][Runtime-available types], otherwise a compiler error should be generated. </span><span class="sentence">The expression checks whether the runtime type of the expression on the left is the same (not the same for <code>!is</code>) as the type denoted by the right-hand side argument.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">Type-checking expression always has type <code>kotlin.Boolean</code>.</span></p>
</div>
<h5 id="todo-1">TODO()</h5>
<ul>
    <li><span class="sentence">Smart casts!</span></li>
</ul>
<h4 id="containment-checking-expression">Containment-checking expression</h4>
<div class="paragraph">
    <p><span class="sentence">A <em>containment-checking expression</em> is a binary expression employing the containment operator (<code>in</code> or <code>!in</code>). </span><span class="sentence">These are [overloadable][Overloadable operators] operators with the following expansion:</span></p>
</div>
<ul>
    <li><span class="sentence"><span class="math inline">\(A\)</span><code>in</code><span class="math inline">\(B\)</span> is exactly the same as <span class="math inline">\(B\)</span><code>.contains(</code><span class="math inline">\(B\)</span><code>)</code>;</span></li>
    <li><span class="sentence"><span class="math inline">\(A\)</span><code>!in</code><span class="math inline">\(B\)</span> is exactly the same as <code>!(</code><span class="math inline">\(B\)</span><code>.contains(</code><span class="math inline">\(B\)</span><code>))</code>;</span></li>
</ul>
<div class="paragraph">
    <p><span class="sentence">where <code>contains</code> is a valid operator function available in the current scope. </span><span class="sentence">This function must have return type <code>kotlin.Boolean</code>, otherwise a compiler error is generated. </span><span class="sentence">Containment-checking expressions always have type <code>kotlin.Boolean</code>.</span></p>
</div>
<h3 id="elvis-operator-expression">Elvis operator expression</h3>
<dl>
    <dt><strong><em>elvisExpression</em>:</strong></dt>
    <dd><span class="sentence"><em>infixFunctionCall</em> {{<em>NL</em>} <code>?:</code> {<em>NL</em>} (<em>infixFunctionCall</em> | <em>ifExpression</em>)}</span>
    </dd>
</dl>
<div class="paragraph">
    <p><span class="sentence"><em>Elvis operator expression</em> is a binary expression that emplys the elvis operator (<code>?:</code>). </span><span class="sentence">It checks whether the left-hand side expression is equal to <code>null</code>, and if it is, evaluates and return the right-hand side expression.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">This operator is <strong>lazy</strong>, meaning that if the left-hand side expression is not equal to <code>null</code>, the right-hand side expression is never evaluated.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">The type of elvis operator expression is the [least upper bound][The least upper bound] of the non-nullable variant of the type of the left-hand side expression and the type of the right-hand side expression. </span><span class="sentence">TODO(): not that simple, too</span></p>
</div>
<h3 id="range-expression">Range expression</h3>
<dl>
    <dt><strong><em>rangeExpression</em>:</strong></dt>
    <dd><span class="sentence"><em>additiveExpression</em> {<code>..</code> {<em>NL</em>} (<em>additiveExpression</em> | <em>ifExpression</em>)}</span>
    </dd>
</dl>
<div class="paragraph">
    <p><span class="sentence">A <em>range expression</em> is a binary expression employing the range operator <code>..</code>. </span><span class="sentence">It is an [overloadable][Overloadable operators] operator with the following expansion:</span></p>
</div>
<ul>
    <li><span class="sentence"><span class="math inline">\(A\)</span><code>..</code><span class="math inline">\(B\)</span> is exactly the same as <span class="math inline">\(A\)</span><code>.rangeTo(</code><span class="math inline">\(B\)</span><code>)</code></span></li>
</ul>
<div class="paragraph">
    <p><span class="sentence">where <code>rangeTo</code> is a valid operator function available in the current scope. </span><span class="sentence">The return type of this function is not restricted. </span><span class="sentence">The range expression has the same type as the return type of the corresponding <code>rangeTo</code> overload variant.</span></p>
</div>
<h3 id="additive-expression">Additive expression</h3>
<dl>
    <dt><strong><em>additiveExpression</em>:</strong></dt>
    <dd><span class="sentence"><em>multiplicativeExpression</em> {<em>additiveOperator</em> {<em>NL</em>} (<em>multiplicativeExpression</em> | <em>ifExpression</em>)}</span>
    </dd>
    <dt><strong><em>additiveOperator</em>:</strong></dt>
    <dd><span class="sentence"><code>+</code> | <code>-</code></span>
    </dd>
</dl>
<div class="paragraph">
    <p><span class="sentence">An <em>additive expression</em> is a binary expression employing the addition (<code>+</code>) or subtraction (<code>-</code>) operators. </span><span class="sentence">These are [overloadable][Overloadable operators] operators with the following expansions:</span></p>
</div>
<ul>
    <li><span class="sentence"><span class="math inline">\(A\)</span><code>+</code><span class="math inline">\(B\)</span> is exactly the same as <span class="math inline">\(A\)</span><code>.plus(</code><span class="math inline">\(B\)</span><code>)</code></span></li>
    <li><span class="sentence"><span class="math inline">\(A\)</span><code>-</code><span class="math inline">\(B\)</span> is exactly the same as <span class="math inline">\(A\)</span><code>.minus(</code><span class="math inline">\(B\)</span><code>)</code></span></li>
</ul>
<div class="paragraph">
    <p><span class="sentence">where <code>plus</code> or <code>minus</code> is a valid operator function available in the current scope. </span><span class="sentence">The return type of this function is not restricted. </span><span class="sentence">The range expression has the same type as the return type of the corresponding operator function overload variant.</span></p>
</div>
<h3 id="multiplicative-expression">Multiplicative expression</h3>
<dl>
    <dt><strong><em>multiplicativeExpression</em>:</strong></dt>
    <dd><span class="sentence"><em>asExpression</em> {<em>multiplicativeOperator</em> {<em>NL</em>} (<em>asExpression</em> | <em>ifExpression</em>)}</span>
    </dd>
    <dt><strong><em>multiplicativeOperator</em>:</strong></dt>
    <dd><span class="sentence"><code>*</code><br />
| <code>/</code><br />
| <code>%</code></span>
    </dd>
</dl>
<div class="paragraph">
    <p><span class="sentence">An <em>multiplicative expression</em> is a binary expression employing the multiplication (<code>*</code>), division (<code>/</code>) or remainder (<code>%</code>) operators. </span><span class="sentence">These are [overloadable][Overloadable operators] operators with the following expansions:</span></p>
</div>
<ul>
    <li><span class="sentence"><span class="math inline">\(A\)</span><code>*</code><span class="math inline">\(B\)</span> is exactly the same as <span class="math inline">\(A\)</span><code>.times(</code><span class="math inline">\(B\)</span><code>)</code></span></li>
    <li><span class="sentence"><span class="math inline">\(A\)</span><code>/</code><span class="math inline">\(B\)</span> is exactly the same as <span class="math inline">\(A\)</span><code>.div(</code><span class="math inline">\(B\)</span><code>)</code></span></li>
    <li><span class="sentence"><span class="math inline">\(A\)</span><code>%</code><span class="math inline">\(B\)</span> is exactly the same as <span class="math inline">\(A\)</span><code>.rem(</code><span class="math inline">\(B\)</span><code>)</code></span></li>
</ul>
<blockquote>
    <div class="paragraph">
        <p><span class="sentence">As of Kotlin version 1.2.31, there exists an additional overloading function for <code>%</code> called <code>mod</code>, which is deprecated</span></p>
    </div>
</blockquote>
<div class="paragraph">
    <p><span class="sentence">where <code>times</code>, <code>div</code>, <code>rem</code> is a valid operator function available in the current scope. </span><span class="sentence">The return type of this function is not restricted. </span><span class="sentence">The range expression has the same type as the return type of the corresponding operator function overload variant.</span></p>
</div>
<h3 id="cast-expression">Cast expression</h3>
<dl>
    <dt><strong><em>asExpression</em>:</strong></dt>
    <dd><span class="sentence"><em>prefixUnaryExpression</em> [{<em>NL</em>} <em>asOperator</em> {<em>NL</em>} <em>type</em>]</span>
    </dd>
    <dt><strong><em>asOperator</em>:</strong></dt>
    <dd><span class="sentence"><code>as</code><br />
| <code>as?</code><br />
| <code>:</code></span>
    </dd>
</dl>
<div class="paragraph">
    <p><span class="sentence">A <em>cast expression</em> is a binary expression employing the cast operators (<code>as</code> or <code>as?</code>) and receives an expression as the left-hand side operand and a type name as the right-hand side operand.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">The form of cast expression employing the <code>as</code> operator is called <em>a unsafe cast</em> expression This operator perform a runtime check whether runtime type of the expression is a <a href="#subtyping">subtype</a> of the type given on the right-hand side operand and throws an exception otherwise. </span><span class="sentence">If the type on the right hand side is a [runtime-available][Runtime-available types] type without generic parameters, then this exception is thrown immediately when evaluating the expression, otherwise it is platform-dependent whether an exception is thrown at this point.</span></p>
</div>
<blockquote>
    <div class="paragraph">
        <p><span class="sentence">Even if the exception is not thrown when evaluating the cast expression, it is guaranteed to be thrown later when the value is used with any runtime-available type</span></p>
    </div>
</blockquote>
<div class="paragraph">
    <p><span class="sentence">The unsafe cast expression always has the same type as the type specified in the expression.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">The form of cast expression employing the <code>as?</code> operator is called <em>a checked cast</em> expression This operator is very similar to the unsafe cast expression, but does not throw an exception, but returns <code>null</code> if the types donâ€™t match. </span><span class="sentence">If the type specified on the right hand side of the expression is not [runtime-available][Runtime-available types], then the check is not performed and <code>null</code> is never returned, leading to potential runtime errors later in the program execution. </span><span class="sentence">This situation should be reported with a compiler warning.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">The checked cast expression always has the <a href="#nullable-types">nullable</a> variant of the type specified in the expression.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">An <em>ascription expression</em> is a binary expression employing the ascription operator (<code>:</code>) and receives an expression as the left-hand side operand and a type name as the right-hand side operand.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">This operator does not perform any actions at runtime and evaluates to the same value as its left hand operand. </span><span class="sentence">However, it does perform a compile-time check whether the current type of the expression is a <a href="#subtyping">subtype</a> of the type given on the right-hand side operand and generates a compiler error otherwise.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">The ascription expression always has the same type as the type specified in right-hand side of the expression.</span></p>
</div>
<h4 id="todo-2">TODO()</h4>
<ul>
    <li><span class="sentence">Smart casts!</span></li>
</ul>
<h3 id="prefix-expressions">Prefix expressions</h3>
<dl>
    <dt><strong><em>prefixUnaryExpression</em>:</strong></dt>
    <dd><span class="sentence">{<em>unaryPrefix</em>} <em>postfixUnaryExpression</em><br />
| <em>unaryPrefix</em> {<em>unaryPrefix</em>} <em>ifExpression</em></span>
    </dd>
    <dt><strong><em>unaryPrefix</em>:</strong></dt>
    <dd><span class="sentence"><em>annotation</em><br />
| <em>labelDefinition</em><br />
| <em>prefixUnaryOperator</em> {<em>NL</em>}</span>
    </dd>
    <dt><strong><em>prefixUnaryOperator</em>:</strong></dt>
    <dd><span class="sentence"><code>++</code><br />
| <code>--</code><br />
| <code>-</code><br />
| <code>+</code><br />
| <code>!</code></span>
    </dd>
</dl>
<h4 id="annotated-and-labeled-expression">Annotated and labeled expression</h4>
<div class="paragraph">
    <p><span class="sentence">Any expression in Kotlin may be prefixed with any number of <a href="#annotations">annotations</a> and [labels][Labels]. </span><span class="sentence">These do not change the value of the expression and can be used by external tools and platform-dependent features.</span></p>
</div>
<h4 id="prefix-increment-expression">Prefix increment expression</h4>
<div class="paragraph">
    <p><span class="sentence">A <em>prefix increment</em> expression is an expression employing the prefix form of operator <code>++</code>. </span><span class="sentence">It is an [overloadable][Overloadable operators] operator with the following expansion:</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence"><code>++</code><span class="math inline">\(A\)</span> is exactly the same as evaluating the expression <span class="math inline">\(A\)</span><code>.inc()</code> where <code>inc</code> is a suitable <code>operator</code> function, assigning the value to <span class="math inline">\(A\)</span> and then returning the value of <span class="math inline">\(A\)</span> as the result of the expression.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">The left-hand side of a postfix increment expression must be an <a href="#assignments">assignable expressions</a>. </span><span class="sentence">Otherwise a compiler error must be generated.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">The type of prefix increment is always equal to the type of the right-hand side expression.</span></p>
</div>
<h4 id="prefix-decrement-expression">Prefix decrement expression</h4>
<div class="paragraph">
    <p><span class="sentence">A <em>prefix increment</em> expression is an expression employing the prefix form of operator <code>--</code>. </span><span class="sentence">It is an [overloadable][Overloadable operators] operator with the following expansion:</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence"><code>--</code><span class="math inline">\(A\)</span> is exactly the same as evaluating the expression <span class="math inline">\(A\)</span><code>.dec()</code> where <code>dec</code> is a suitable <code>operator</code> function, assigning the value to <span class="math inline">\(A\)</span> and then returning the value of <span class="math inline">\(A\)</span> as the result of the expression.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">The left-hand side of a prefix decrement expression must be an <a href="#assignments">assignable expressions</a>. </span><span class="sentence">Otherwise a compiler error must be generated.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">The type of prefix increment is always equal to the type of the right-hand side expression.</span></p>
</div>
<h4 id="unary-minus-expression">Unary minus expression</h4>
<div class="paragraph">
    <p><span class="sentence">An <em>unary minus</em> expression is an expression employing the prefix form of operator <code>-</code>. </span><span class="sentence">It is an [overloadable][Overloadable operators] operator with the following expansion:</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence"><code>-</code><span class="math inline">\(A\)</span> is exactly the same as <span class="math inline">\(A\)</span><code>.unaryMinus()</code> where <code>unaryMinus</code> is a suitable <code>operator</code> function, including its type. </span><span class="sentence">No additional restrictions apply.</span></p>
</div>
<h4 id="unary-plus-expression">Unary plus expression</h4>
<div class="paragraph">
    <p><span class="sentence">An <em>unary plus</em> expression is an expression employing the prefix form of operator <code>+</code>. </span><span class="sentence">It is an [overloadable][Overloadable operators] operator with the following expansion:</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence"><code>+</code><span class="math inline">\(A\)</span> is exactly the same as <span class="math inline">\(A\)</span><code>.unaryPlus()</code> where <code>unaryPlus</code> is a suitable <code>operator</code> function, including its type. </span><span class="sentence">No additional restrictions apply.</span></p>
</div>
<h4 id="logical-not-expression">Logical not expression</h4>
<div class="paragraph">
    <p><span class="sentence">A <em>logical not</em> expression is an expression employing the prefix operator <code>!</code>. </span><span class="sentence">It is an [overloadable][Overloadable operators] operator with the following expansion:</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence"><code>!</code><span class="math inline">\(A\)</span> is exactly the same as <span class="math inline">\(A\)</span><code>.not()</code> where <code>not</code> is a suitable <code>operator</code> function, including its type. </span><span class="sentence">No additional restrictions apply.</span></p>
</div>
<h3 id="postfix-operator-expressions">Postfix operator expressions</h3>
<dl>
    <dt><strong><em>postfixUnaryExpression</em>:</strong></dt>
    <dd><span class="sentence"><em>primaryExpression</em> {<em>postfixUnarySuffix</em>}</span>
    </dd>
    <dt><strong><em>postfixUnarySuffix</em>:</strong></dt>
    <dd><span class="sentence"><em>postfixUnaryOperator</em><br />
| <em>typeArguments</em><br />
| <em>callSuffix</em><br />
| <em>indexingSuffix</em><br />
| <em>navigationSuffix</em></span>
    </dd>
    <dt><strong><em>postfixUnaryOperator</em>:</strong></dt>
    <dd><span class="sentence"><code>++</code><br />
| <code>--</code><br />
| <code>!!</code></span>
    </dd>
</dl>
<h4 id="postfix-increment-expression">Postfix increment expression</h4>
<div class="paragraph">
    <p><span class="sentence">A <em>postfix increment</em> expression is an expression employing the postfix form of operator <code>++</code>. </span><span class="sentence">It is an [overloadable][Overloadable operators] operator with the following expansion:</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence"><span class="math inline">\(A\)</span><code>++</code> is exactly the same as evaluating the expression <span class="math inline">\(A\)</span><code>.inc()</code> where <code>inc</code> is a suitable <code>operator</code> function, assigning the value of <span class="math inline">\(A\)</span> to a temporary location, assigning the result of <code>inc</code> to <span class="math inline">\(A\)</span> and returning the temporary.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">It can also be represented with the following code:</span></p>
</div>
<div class="sourceCode" id="cb11"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">val</span> <span class="va">tmp</span> = A;</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">A = A.inc();</a>
<a class="sourceLine" id="cb11-3" data-line-number="3"><span class="kw">return</span> tmp;</a></code></pre></div>
<div class="paragraph">
    <p><span class="sentence">The left-hand side of a postfix increment expression must be an [assignable expressions][Assignable expressions]. </span><span class="sentence">Otherwise a compiler error must be generated.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">The type of postfix increment is always equal to the type of the right-hand side expression.</span></p>
</div>
<h4 id="postfix-decrement-expression">Postfix decrement expression</h4>
<div class="paragraph">
    <p><span class="sentence">A <em>postfix decrement</em> expression is an expression employing the postfix form of operator <code>--</code>. </span><span class="sentence">It is an [overloadable][Overloadable operators] operator with the following expansion:</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence"><span class="math inline">\(A\)</span><code>--</code> is exactly the same as evaluating the expression <span class="math inline">\(A\)</span><code>.dec()</code> where <code>dec</code> is a suitable <code>operator</code> function, assigning the value of <span class="math inline">\(A\)</span> to a temporary location, assigning the result of <code>inc</code> to <span class="math inline">\(A\)</span> and returning the temporary.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">It can also be represented with the following code:</span></p>
</div>
<div class="sourceCode" id="cb12"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">val</span> <span class="va">tmp</span> = A;</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">A = A.dec();</a>
<a class="sourceLine" id="cb12-3" data-line-number="3"><span class="kw">return</span> tmp;</a></code></pre></div>
<div class="paragraph">
    <p><span class="sentence">The left-hand side of a postfix decrement expression must be an [assignable expressions][Assignable expressions]. </span><span class="sentence">Otherwise a compiler error must be generated.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">The type of prefix increment is always equal to the type of the right-hand side expression.</span></p>
</div>
<h3 id="not-null-assertion-expression">Not-null assertion expression</h3>
<div class="paragraph">
    <p><span class="sentence">A <em>not-null assertion expression</em> is a postfix expression employing the use of operator <code>!!</code>. </span><span class="sentence">For expressions of nullabe types, this expression checks whether the value is equal to <code>null</code>, and if it is, throws a runtime exception. </span><span class="sentence">If it is not equal to <code>null</code>, it evaluates to the same value as its left-hand side expression.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">Not-null assertion expressions have no effect on values of non-nullable types.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">The type of non-null assertion expression is the <a href="#nullable-types">non-nullable</a> variant of the type of its left-hand side expression. </span><span class="sentence">Note that this type may be non-denotable in Kotlin and as such, may be [approximated][Type approximation] in some situations involving <a href="#type-inference">type inference</a>.</span></p>
</div>
<h3 id="indexing-expressions">Indexing expressions</h3>
<dl>
    <dt><strong><em>postfixUnaryExpression</em>:</strong></dt>
    <dd><span class="sentence"><em>primaryExpression</em> {<em>postfixUnarySuffix</em>}</span>
    </dd>
    <dt><strong><em>postfixUnarySuffix</em>:</strong></dt>
    <dd><span class="sentence"><em>postfixUnaryOperator</em><br />
| <em>typeArguments</em><br />
| <em>callSuffix</em><br />
| <em>indexingSuffix</em><br />
| <em>navigationSuffix</em></span>
    </dd>
    <dt><strong><em>indexingSuffix</em>:</strong></dt>
    <dd><span class="sentence"><code>[</code> {<em>NL</em>} <em>expression</em> {{<em>NL</em>} <code>,</code> {<em>NL</em>} <em>expression</em>} {<em>NL</em>} <code>]</code></span>
    </dd>
</dl>
<div class="paragraph">
    <p><span class="sentence">An <em>indexing expression</em> is a suffix expression employing the use of several subexpressions <em>indices</em> between square brackets (<code>[</code> and <code>]</code>). </span><span class="sentence">At least one index must be provided.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">It is an [overloadable][Overloadable operators] operator with the following expansion:</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence"><span class="math inline">\(A\)</span><code>[</code><span class="math inline">\(I_0\)</span><code>,</code><span class="math inline">\(I_1\)</span><code>,</code><span class="math inline">\(\ldots\)</span><code>,</code><span class="math inline">\(I_N\)</span><code>]</code> is exactly the same as <span class="math inline">\(A\)</span><code>.get(</code><span class="math inline">\(I_0\)</span><code>,</code><span class="math inline">\(I_1\)</span><code>,</code><span class="math inline">\(\ldots\)</span><code>,</code><span class="math inline">\(I_N\)</span><code>)</code>, where <code>get</code> is a suitable <code>operator</code> function.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">A correct indexing expression has the same type as the corresponding <code>get</code> expression.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">Indexing expressions are [assignable][Assignable expressions]. </span><span class="sentence">For a corresponding assignment form, see [indexing assignment][Indexing assignment].</span></p>
</div>
<h3 id="call-and-property-access-expressions">Call and property access expressions</h3>
<dl>
    <dt><strong><em>postfixUnaryExpression</em>:</strong></dt>
    <dd><span class="sentence"><em>primaryExpression</em> {<em>postfixUnarySuffix</em>}</span>
    </dd>
    <dt><strong><em>postfixUnarySuffix</em>:</strong></dt>
    <dd><span class="sentence"><em>postfixUnaryOperator</em><br />
| <em>typeArguments</em><br />
| <em>callSuffix</em><br />
| <em>indexingSuffix</em><br />
| <em>navigationSuffix</em></span>
    </dd>
    <dt><strong><em>navigationSuffix</em>:</strong></dt>
    <dd><span class="sentence">{<em>NL</em>} <em>memberAccessOperator</em> {<em>NL</em>} (<em>simpleIdentifier</em> | <code>class</code>)</span>
    </dd>
    <dt><strong><em>callSuffix</em>:</strong></dt>
    <dd><span class="sentence">[<em>typeArguments</em>] [<em>valueArguments</em>] <em>annotatedLambda</em><br />
| [<em>typeArguments</em>] <em>valueArguments</em></span>
    </dd>
    <dt><strong><em>annotatedLambda</em>:</strong></dt>
    <dd><span class="sentence">{annotation | <em>IdentifierAt</em>} {<em>NL</em>} <em>lambdaLiteral</em></span>
    </dd>
    <dt><strong><em>valueArguments</em>:</strong></dt>
    <dd><span class="sentence"><code>(</code> {<em>NL</em>} [<em>valueArgument</em>] {<em>NL</em>} <code>)</code><br />
| <code>(</code> {<em>NL</em>} <em>valueArgument</em> {{<em>NL</em>} <code>,</code> {<em>NL</em>} <em>valueArgument</em>} {<em>NL</em>} <code>)</code></span>
    </dd>
    <dt><strong><em>typeArguments</em>:</strong></dt>
    <dd><span class="sentence"><code>&lt;</code> {<em>NL</em>} <em>typeProjection</em> {{<em>NL</em>} <code>,</code> {<em>NL</em>} <em>typeProjection</em>} {<em>NL</em>} <code>&gt;</code></span>
    </dd>
    <dt><strong><em>typeProjection</em>:</strong></dt>
    <dd><span class="sentence">[<em>typeProjectionModifierList</em>] <em>type</em> | <code>*</code></span>
    </dd>
    <dt><strong><em>typeProjectionModifierList</em>:</strong></dt>
    <dd><span class="sentence">{<em>varianceAnnotation</em>}</span>
    </dd>
    <dt><strong><em>navigationSuffix</em>:</strong></dt>
    <dd><span class="sentence">{<em>NL</em>} <em>memberAccessOperator</em> {<em>NL</em>} (<em>simpleIdentifier</em> | <code>class</code>)</span>
    </dd>
    <dt><strong><em>memberAccessOperator</em>:</strong></dt>
    <dd><span class="sentence"><code>.</code> | <code>?.</code> | <code>::</code></span>
    </dd>
</dl>
<h4 id="the-navigation-operators">The navigation operators</h4>
<div class="paragraph">
    <p><span class="sentence">Expressions employing the navigation binary operators (<code>.</code>, <code>.?</code> or <code>::</code>) are all syntactically similar, but, in fact, may have very different syntactic meaning. </span><span class="sentence"><code>a.c</code> may have one of the following semantics when used as an expression:</span></p>
</div>
<ul>
    <li><span class="sentence">A fully-qualified type, property or object name. </span><span class="sentence">The left side of <code>.</code> must be a package name, while the right side corresponds to a declaration in that package. </span><span class="sentence">Note that qualification uses operator <code>.</code> only;</span></li>
    <li><span class="sentence">A value property access. </span><span class="sentence">Here <code>a</code> is another value available in the current scope and <code>c</code> is the property name. </span><span class="sentence">If used with operator <code>::</code> this becomes a [property reference][Callable references]. </span><span class="sentence">The left-hand side expression may be a type name, which is similar to using the typeâ€™s companion object as the left hand side expression;</span></li>
    <li><span class="sentence">A member function call if followed by the call suffix (arguments enclosed in parentheses). </span><span class="sentence">These expressions adhere to the <a href="#overload-resolution">overloading</a> rules. </span><span class="sentence">If used with operator <code>::</code>, but without the call suffix, this becomes a [function reference][Callable references].</span></li>
</ul>
<div class="paragraph">
    <p><span class="sentence">TODO() + Identifiers</span></p>
</div>
<h3 id="function-literals">Function Literals</h3>
<div class="paragraph">
    <p><span class="sentence">Kotlin supports using functions as values. </span><span class="sentence">This includes, among other things, being able to use named functions (through [function references][Callable references]) as parts of expressions. </span><span class="sentence">Sometimes it does not make much sense to provide a separate function declaration, but rather define a function in-place, using <em>function literals</em>.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">There are two types of function literals in Kotlin: <em>lambda literals</em> and <em>anonymous function declarations</em>. </span><span class="sentence">Both of these provide a way of defining a function in-place, but have subtle differences.</span></p>
</div>
<h4 id="anonymous-function-declarations">Anonymous function declarations</h4>
<dl>
    <dt><strong><em>anonymousFunction</em>:</strong></dt>
    <dd><span class="sentence"><code>fun</code><br />
[{<em>NL</em>} <em>type</em> {<em>NL</em>} <code>.</code>]<br />
{<em>NL</em>} <em>functionValueParameters</em><br />
[{<em>NL</em>} <code>:</code> {<em>NL</em>} <em>type</em>]<br />
[{<em>NL</em>} <em>typeConstraints</em>]<br />
[{<em>NL</em>} <em>functionBody</em>]</span>
    </dd>
</dl>
<div class="paragraph">
    <p><span class="sentence"><em>Anonymous function declarations</em>, despite the name, are not actually declarations, but rather an expression that resembles a function declaration. </span><span class="sentence">They have syntax very similar to the function declaration syntax, but with a few differences:</span></p>
</div>
<ul>
    <li><span class="sentence">Anonymous functions do not have a name (obviously);</span></li>
    <li><span class="sentence">Anonymous functions may not have type parameters (TODO(): check!!!);</span></li>
    <li><span class="sentence">Anonymous functions may not have default parameters (TODO(): check!!!);</span></li>
    <li><span class="sentence">Anonymous functions may have variable argument parameters, but they are automatically decayed to non-variable argument parameters of array type (TODO(): how does this really work?).</span></li>
</ul>
<div class="paragraph">
    <p><span class="sentence">Anonymous function declaration may declare anonymous extension functions. </span><span class="sentence">The type of an anonymous function declaration is the function type constructed similarly to the corresponding [named function declaration][Function declarations].</span></p>
</div>
<h4 id="lambda-literals">Lambda literals</h4>
<dl>
    <dt><strong><em>lambdaLiteral</em>:</strong></dt>
    <dd><span class="sentence"><code>{</code> {<em>NL</em>} <em>statements</em> {<em>NL</em>} <code>}</code><br />
| <code>{</code> {<em>NL</em>} <em>lambdaParameters</em> {<em>NL</em>} <code>-&gt;</code> {<em>NL</em>} <em>statements</em> {<em>NL</em>} <code>}</code></span>
    </dd>
    <dt><strong><em>lambdaParameters</em>:</strong></dt>
    <dd><span class="sentence">[<em>lambdaParameter</em>] {{<em>NL</em>} <code>,</code> {<em>NL</em>} <em>lambdaParameter</em>}</span>
    </dd>
    <dt><strong><em>lambdaParameter</em>:</strong></dt>
    <dd><span class="sentence"><em>variableDeclaration</em><br />
| <em>multiVariableDeclaration</em> [{<em>NL</em>} <code>:</code> {<em>NL</em>} <em>type</em>]</span>
    </dd>
</dl>
<div class="paragraph">
    <p><span class="sentence">Lambda literals TODO()</span></p>
</div>
<h3 id="object-literals">Object literals</h3>
<dl>
    <dt><strong><em>objectLiteral</em>:</strong></dt>
    <dd><span class="sentence"><code>object</code> {<em>NL</em>} <code>:</code> {<em>NL</em>} <em>delegationSpecifiers</em> [{<em>NL</em>} <em>classBody</em>]<br />
| <code>object</code> {<em>NL</em>} <em>classBody</em></span>
    </dd>
</dl>
<div class="paragraph">
    <p><span class="sentence">Object literals are a way of defining anonymous objects in Kotlin. </span><span class="sentence">Anonymous objects are similar to regular objects, but they (obviously) have no name and thus can (only) be used as expressions. </span><span class="sentence">Anonymous objects, just like regular object declarations, can have at most one base class and many base interfaces declared in its delegation specifiers.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">The main difference between the regular object declaration and an anonymous object is its type. </span><span class="sentence">The type of an anonymous object is a special kind of type that is usable (and visible) only in the scope where it is declared. </span><span class="sentence">It is similar to a type that could be normally declared with a corresponding object declaration, but cannot be used outside the scope, leading to interesting effects.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">When a value of this type escapes current scope:</span></p>
</div>
<ul>
    <li><span class="sentence">If the type has only one declared supertype, it is implicitly downcasted to this declared supertype;</span></li>
    <li><span class="sentence">If the type has several declared supertypes, there must be an explicit cast to any suitable type visible outside the scope, otherwise a compiler error is generated.</span></li>
</ul>
<div class="paragraph">
    <p><span class="sentence">Please not that in this context â€œescapingâ€ current scope is performed immediately if the corresponding value is declared as a global or classifier-scope property, as those are a part of package interface.</span></p>
</div>
<h3 id="this-expressions">This-expressions</h3>
<dl>
    <dt><strong><em>thisExpression</em>:</strong></dt>
    <dd><span class="sentence"><code>this</code> [<em>AtIdentifier</em>]</span>
    </dd>
</dl>
<div class="paragraph">
    <p><span class="sentence">This-expressions are a special kind of expressions used to access available receivers in current scope. </span><span class="sentence">For more information about receivers, please refer to the <a href="#receivers">overloading section</a>. </span><span class="sentence">The basic form of this expression, denoted by <code>this</code> keyword, is used to access the current implicit receiver according to receiver overloading rules. </span><span class="sentence">In order to access other receivers, labeled <code>this</code> expressions are used. </span><span class="sentence">These may be any of the following:</span></p>
</div>
<ul>
    <li><span class="sentence"><code>this@</code><span class="math inline">\(type\)</span> where <span class="math inline">\(type\)</span> is a name of any classifier that is currently being declared (that is, this this-expression is located inside its declarationâ€™s inner scope) refers to the implicit object of the type being declared;</span></li>
    <li><span class="sentence"><code>this@</code><span class="math inline">\(function\)</span> where <span class="math inline">\(function\)</span> is a name of a function currently being declared (that is, this this-expression is located inside the function body) refers to the implicit receiver object of this function (if it is an extension function) or is illegal and generates a compiler error.</span></li>
</ul>
<div class="paragraph">
    <p><span class="sentence">Any other form of this-expression is illegal and generates a compiler error.</span></p>
</div>
<h3 id="super-forms">Super-forms</h3>
<dl>
    <dt><strong><em>superExpression</em>:</strong></dt>
    <dd><span class="sentence"><code>super</code> [<code>&lt;</code> {<em>NL</em>} <em>type</em> {<em>NL</em>} <code>&gt;</code>] [<em>AtIdentifier</em>]</span>
    </dd>
</dl>
<div class="paragraph">
    <p><span class="sentence">Super form is a special kind of expression that can only be used as the receiver of a function or property access expression. </span><span class="sentence">Any usage of such an expression in any other context is prohibited.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">Super forms are used in classifier declarations to access the method implementations from base classifier types without invoking overriding behaviour.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">TODO()</span></p>
</div>
<h3 id="jump-expressions">Jump expressions</h3>
<dl>
    <dt><strong><em>jumpExpression</em>:</strong></dt>
    <dd><span class="sentence"><code>throw</code> {<em>NL</em>} <em>expression</em><br />
| (<code>return</code> | <code>return@</code> <em>Identifier</em>) [<em>expression</em>]<br />
| <code>continue</code> | <code>continue@</code> <em>Identifier</em><br />
| <code>break</code> | <code>break@</code> <em>Identifier</em></span>
    </dd>
</dl>
<div class="paragraph">
    <p><span class="sentence"><em>Jump expressions</em> are a group of expressions that redirect the order the program is evaluated to a different program point when evaluated. </span><span class="sentence">All these expressions have several things in common:</span></p>
</div>
<ul>
    <li><span class="sentence">They all have type <code>kotlin.Nothing</code>, effectively meaning that they never produce any runtime value;</span></li>
    <li><span class="sentence">Any code that unconditionally follows such expression is never evaluated.</span></li>
</ul>
<h4 id="throw-expressions">Throw expressions</h4>
<div class="paragraph">
    <p><span class="sentence">TODO(): [Exceptions] go first</span></p>
</div>
<h4 id="return-expressions">Return expressions</h4>
<div class="paragraph">
    <p><span class="sentence">A <em>return expression</em>, when used inside a function body, immediately stops evaluating the function and returns to the point where this function was called, making the function call expression evaluate to the value specified in this return expression (if any). </span><span class="sentence">A return expression with no value implicitly returns the <code>kotlin.Unit</code> object.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">There are two forms of return expression: a simple return expression, specified using the <code>return</code> keyword, returning from the innermost <a href="#function-declaration">function declaration</a> (or [anonymous function expression][Anonymous function expression]) and the extended return expression, using the form <code>return@</code><span class="math inline">\(Context\)</span> where <span class="math inline">\(Context\)</span> may be one of the following:</span></p>
</div>
<ul>
    <li><span class="sentence">The name of one of the enclosing function declarations to refer to this function. </span><span class="sentence">If several declarations match one name, an ambiguity compiler error is generated;</span></li>
    <li><span class="sentence">If current expression is inside a lambda expression body, the name of the function using this lambda expression as a trailing lambda (TODO: Wut?) parameter may be used to refer to the lambda literal itself.</span></li>
</ul>
<div class="paragraph">
    <p><span class="sentence">If returning from the referred function is allowed in current context, the return is performed as usual. </span><span class="sentence">If returning from the referred function is not allowed, a compiler error is generated.</span></p>
</div>
<h4 id="continue-expression">Continue expression</h4>
<div class="paragraph">
    <p><span class="sentence">A <em>continue expression</em> is a jump expression allowed only within loop bodies. </span><span class="sentence">When evaluated, this expression passes the control to the start of the next loop iteration.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">There are two forms of continue expressions:</span></p>
</div>
<ul>
    <li><span class="sentence">A simple continue expression, specified using the <code>continue</code> keyword, which refers to the innermost loop statement in the current scope;</span></li>
    <li><span class="sentence">An extended continue expression, denoted <code>continue@</code><span class="math inline">\(Loop\)</span>, where <span class="math inline">\(Loop\)</span> is a label referring to a labeled loop statement, which refers to the loop the label refers to.</span></li>
</ul>
<div class="paragraph">
    <p><span class="sentence">TODO(): as a matter of fact, <code>continue</code> is not allowed inside <code>when</code> &gt;_&lt;</span></p>
</div>
<h4 id="break-expression">Break expression</h4>
<div class="paragraph">
    <p><span class="sentence">A <em>break expression</em> is a jump expression allowed only within loop bodies. </span><span class="sentence">When evaluated, this expression passes the control to the next program point after the loop.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">There are two forms of break expressions:</span></p>
</div>
<ul>
    <li><span class="sentence">A simple break expression, specified using the <code>break</code> keyword, which refers to the innermost loop statement in the current scope;</span></li>
    <li><span class="sentence">An extended break expression, denoted <code>break@</code><span class="math inline">\(Loop\)</span>, where <span class="math inline">\(Loop\)</span> is a label referring to a labeled loop statement, which refers to the loop the label refers to.</span></li>
</ul>
<div class="paragraph">
    <p><span class="sentence">TODO(): as a matter of fact, <code>break</code> is not allowed inside <code>when</code> &gt;_&lt;</span></p>
</div>
<h3 id="operator-expressions">Operator expressions</h3>
<h4 id="spread-operator">Spread operator</h4>
<h3 id="safe-call-expression">Safe call expression</h3>
<h3 id="type-check-expression">Type check expression</h3>
<h2 id="todos">TODOS()</h2>
<ul>
    <li><span class="sentence">Overloadable operators &amp;&amp; operator expansion</span></li>
    <li><span class="sentence">Smart casts vs compile-time types</span></li>
    <li><div class="paragraph">
        <p><span class="sentence">What does <code>decaying</code> for vararg actually mean?</span></p>
    </div></li>
    <li><span class="sentence">!!! </span><span class="sentence">object literal typing looks just like restricted union types. </span><span class="sentence">Are there any traps hidden here?</span></li>
    <li><span class="sentence">The whole last paragraph in <a href="#object-literals">Object literals</a> is pretty shady</span></li>
    <li><div class="paragraph">
        <p><span class="sentence">What does it mean for returning to be disallowed?</span></p>
    </div></li>
</ul>
<h2 id="order-of-evaluation">Order of evaluation</h2>
<div class="paragraph">
    <p><span class="sentence">TODO()</span></p>
</div>
<h2 id="semantics">Semantics</h2>
<div class="paragraph">
    <p><span class="sentence">TODO()</span></p>
</div>
<h3 id="smart-casts">Smart casts</h3>
<h2 id="control--and-data-flow-analysis">Control- and data-flow analysis</h2>
<div class="paragraph">
    <p><span class="sentence">TODO()</span></p>
</div>
<h2 id="type-inference">Type inference</h2>
<div class="paragraph">
    <p><span class="sentence">TODO()</span></p>
</div>
<h2 id="overload-resolution">Overload resolution</h2>
<div class="paragraph">
    <p><span class="sentence">Kotlin supports <em>function overloading</em>, that is, the ability for several functions of the same name to coexist in the same scope, with the compiler picking the most suitable one when such a function is called. </span><span class="sentence">This section describes this mechanism in detail.</span></p>
</div>
<h3 id="intro">Intro</h3>
<div class="paragraph">
    <p><span class="sentence">Unlike other object-oriented languages, Kotlin does not only have object methods, but also top-level functions, local functions, extension functions and function-like values, which complicates the overloading process quite a lot. </span><span class="sentence">Kotlin also has infix functions, operator and property overloading which all work in a similar but rather different way.</span></p>
</div>
<h3 id="receivers">Receivers</h3>
<div class="paragraph">
    <p><span class="sentence">Every function or property that is defined as a method or an extension has one or more special parameters called <em>receiver</em> parameters. </span><span class="sentence">When calling such a callable using navigation operators (<code>.</code> or <code>?.</code>) the left hand side parameter is called an <em>explicit receiver</em> or this particular call. </span><span class="sentence">In addition to the explicit receiver, each such call may indirectly access zero or more <em>implicit receivers</em>.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">Implicit receivers are available in some syntactic scope according to the following rules:</span></p>
</div>
<ul>
    <li><span class="sentence">All receivers available in outer scope are also available in all nested scopes;</span></li>
    <li><span class="sentence">In the scope of a classifier definition, the following receivers are available:</span>
        <ul>
            <li><span class="sentence">The implicit <code>this</code> object of the defined type;</span></li>
            <li><span class="sentence">The companion object (if one exist) of this class;</span></li>
            <li><span class="sentence">The companion objects (if any exists) of all its superclasses;</span></li>
        </ul></li>
    <li><span class="sentence">If a function or a property is an extension, the <code>this</code> parameter of the extension is also available inside the extension definition;</span></li>
    <li><span class="sentence">The scope of a lambda expression if it has an extension function type contains the <code>this</code> argument of this lambda expression.</span></li>
</ul>
<div class="paragraph">
    <p><span class="sentence">The available receivers are prioritized in the following way:</span></p>
</div>
<ul>
    <li><span class="sentence">The receivers provided in most inner scope have higher priority;</span></li>
    <li><span class="sentence">In a classifier body, the implicit <code>this</code> reference has higher priority than the companion object receiver;</span></li>
    <li><span class="sentence">Current class companion object receiver has higher priority than any of the base classes.</span></li>
</ul>
<div class="paragraph">
    <p><span class="sentence">The implicit receiver having the highest priority is also called the <em>default implicit receiver</em>. </span><span class="sentence">The default implicit receiver is available in the scope as <code>this</code>. </span><span class="sentence">Other available receivers may be accessed using <a href="#this-expressions">this-expressions</a> of different form.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">If an implicit receiver is available in some scope, it may be used to call functions implicitely without using the navigation operator.</span></p>
</div>
<h3 id="the-forms-of-call-expression">The forms of call-expression</h3>
<div class="paragraph">
    <p><span class="sentence">Any function in Kotlin may be called in several different ways:</span></p>
</div>
<ul>
    <li><span class="sentence">A fully-qualified call: <code>package.foo()</code>;</span></li>
    <li><span class="sentence">A call with an explicit receiver: <code>a.foo()</code>;</span></li>
    <li><span class="sentence">An infix function call: <code>a foo b</code>;</span></li>
    <li><span class="sentence">An overloaded operator call: <code>a + b</code>;</span></li>
    <li><span class="sentence">A call without an explicit receiver: <code>foo()</code>;</span></li>
</ul>
<div class="paragraph">
    <p><span class="sentence">For each of these cases, a compiler should first pick a number of <em>overload candidates</em> which is a set of callables that may be the intended callees and then <em>choose the most specific function</em> to call based on the types of the function and the call operands. </span><span class="sentence">Please note that the overload candidates are picked <strong>before</strong> the most specific function is chosen.</span></p>
</div>
<h3 id="callables-and-invoke-convention">Callables and invoke convention</h3>
<div class="paragraph">
    <p><span class="sentence">A <em>callable</em> <span class="math inline">\(X\)</span> for the purpose of this document is one of the following:</span></p>
</div>
<ul>
    <li><span class="sentence">A function named <span class="math inline">\(X\)</span> at declaration site;</span></li>
    <li><span class="sentence">A property named <span class="math inline">\(X\)</span> at declaration site with an operator function called <code>invoke</code> that is available as member or extension in the current scope.</span></li>
</ul>
<div class="paragraph">
    <p><span class="sentence">In the latter case a call <span class="math inline">\(X\)</span><code>(</code><span class="math inline">\(Y_0\)</span><code>,</code><span class="math inline">\(Y_1\)</span><code>,...,</code><span class="math inline">\(Y_N\)</span><code>)</code> is an overloadable operator which is expanded to <span class="math inline">\(X\)</span><code>.invoke(</code><span class="math inline">\(Y_0\)</span><code>,</code><span class="math inline">\(Y_1\)</span><code>,...,</code><span class="math inline">\(Y_N\)</span><code>)</code>. </span><span class="sentence">The call may contain type parameters, named parameters, variable argument parameter expansion and trailing lambda parameters, all of which are forwarded as-is to the corresponding <code>invoke</code> function.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">A <em>member callable</em> is either a member function or a member property with member operator <code>invoke</code>. </span><span class="sentence">An <em>extension callable</em> is either an extension function, a member property with an extension operator <code>invoke</code> or an extension property with an extension operator <code>invoke</code>.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">When calculating overload resolution sets, member callables produce the following separate sets (ordered by priority, bigger priority first): - Member functions; - Member properties.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">Extension callables produce the following separate sets (ordered by priority, bigger priority first): - Extension functions; - Member properties with extension invoke; - Extension properties with member invoke; - Extension properties with extension invoke.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">This division is more granular than all other means of dividing resolution candidates into sets, meaning that it is performed the last.</span></p>
</div>
<h3 id="overload-resolution-for-a-fully-qualified-call">Overload resolution for a fully-qualified call</h3>
<div class="paragraph">
    <p><span class="sentence">If the callable name is fully-qualified (that is, contains full package path), then the overloading candidate set simply contains all the callables with the same name in the same package. </span><span class="sentence">As a package name may never clash with any other declared entity, after performing division of callables, these are the only sets available.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">Example:</span></p>
</div>
<div class="sourceCode" id="cb13"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">package</span> <span class="im">a.b.c</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2"></a>
<a class="sourceLine" id="cb13-3" data-line-number="3"><span class="kw">fun</span> <span class="fu">foo</span>(<span class="va">a</span>: <span class="dt">Int</span>) {}</a>
<a class="sourceLine" id="cb13-4" data-line-number="4"><span class="kw">fun</span> <span class="fu">foo</span>(<span class="va">a</span>: <span class="dt">Double</span>) {}</a>
<a class="sourceLine" id="cb13-5" data-line-number="5"><span class="kw">fun</span> <span class="fu">foo</span>(<span class="va">a</span>: <span class="dt">List</span>&lt;<span class="va">Char</span>&gt;) {}</a>
<a class="sourceLine" id="cb13-6" data-line-number="6"><span class="kw">val</span> <span class="va">foo</span> = {}</a>
<a class="sourceLine" id="cb13-7" data-line-number="7">. . .</a>
<a class="sourceLine" id="cb13-8" data-line-number="8">a.b.c.foo()</a></code></pre></div>
<div class="paragraph">
    <p><span class="sentence">Here the overload candidates set contains all the callables named <code>foo</code> from the package <code>a.b.c</code>.</span></p>
</div>
<h3 id="a-call-with-an-explicit-receiver">A call with an explicit receiver</h3>
<div class="paragraph">
    <p><span class="sentence">If a function call is done using a navigation operator (<code>.</code> or <code>?.</code>, not to be confused with a <a href="#overload-resolution-for-a-fully-qualified-call">fully-qualified call</a>), then the left hand side operand of this operator is the explicit receiver of this call.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">A call of callable <code>f</code> with explicit receiver <code>e</code> is correct if one (or more) of the following holds:</span></p>
</div>
<ol type="1">
    <li><span class="sentence"><code>f</code> is a member callable of the classifier type of <code>e</code> or any of its supertypes;</span></li>
    <li><span class="sentence"><code>f</code> is an extension callable for the classifier type of <code>e</code> or any of its supertypes, including local and imported extensions.</span></li>
</ol>
<div class="paragraph">
    <p><span class="sentence">Please note that callables functions for case 2 not only include top-level declared extension callables, but also extension callables available in any of the available implicit receivers. </span><span class="sentence">For example, if a class contains a member extension function for another class and an object of this class is available as an implicit receiver, this extension function may be used for the call if it has a suitable type.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">Then for a callable named <code>f</code> the following sets are looked upon (in this order):</span></p>
</div>
<ol type="1">
    <li><span class="sentence">The sets of non-extension member callables named <code>f</code> of the receiver type;</span></li>
    <li><span class="sentence">The sets of local extension callables named <code>f</code> whose receiver type conforms to the explicit receiver type, in all declaration scopes containing the current declaration scope, ordered by the size of the scope (smallest first), excluding the package scope;</span></li>
    <li><span class="sentence">The sets of explicitly imported extension callables named <code>f</code> whose receiver type conforms to the explicit receiver type;</span></li>
    <li><span class="sentence">The sets of extension callables named <code>f</code> whose receiver type conforms to the explicit receiver type, declared in the current package;</span></li>
    <li><span class="sentence">The sets of star-imported extension callables named <code>f</code> whose receiver type conforms to the explicit receiver type;</span></li>
    <li><span class="sentence">The sets of implicitly imported extension callables named <code>f</code> whose receiver type conforms to the explicit receiver type.</span></li>
</ol>
<div class="paragraph">
    <p><span class="sentence">TODO() : all this X-imported things need to be defined somewhere</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">When looked upon these sets, the first set that contains <strong>any</strong> callable with the corresponding name and conforming types is picked. </span><span class="sentence">This means, among other things, that if the set constructed during step 2 contains a more suitable candidate function, but the set constructed in step 1 is not empty, the function from set 1 is picked even it is a less suitable candidate.</span></p>
</div>
<h3 id="infix-function-calls">Infix function calls</h3>
<div class="paragraph">
    <p><span class="sentence">In reality, infix function calls are a special case of function calls with an explicit receiver using the left hand operand as the receiver.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">There is a slight difference though: during the overload candidate set selection the only functions considered for inclusion are the ones with the <code>infix</code> modifier. </span><span class="sentence">All other functions (and all properties) are not even considered for inclusion. </span><span class="sentence">Aside from this small difference, candidates are selected using the same rules as for normal calls with explicit receiver.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">Different platform implementations may extend the set of functions deemed valid candidates for inclusion as infix functions.</span></p>
</div>
<h3 id="operator-calls">Operator calls</h3>
<div class="paragraph">
    <p><span class="sentence">According to TODO(), some operator expressions in Kotlin can be overloaded using specially-named functions. </span><span class="sentence">This makes operator expressions semantically equivalent to function calls with explicit receiver, where the receiver expression is selected according to operator form (see TODO()). </span><span class="sentence">The selection of an exact function that is called in each particular case is based on the same rules as for function calls with explicit receivers, the only difference being that only functions with <code>operator</code> modifier are considered for inclusion when building overload candidate sets. </span><span class="sentence">Properties are never considered for inclusion for operator calls.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">Different platform implementations may extend the set of functions deemed valid candidates for inclusion as operator functions.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">Please note that this is valid not only for dedicated operator expressions, but also for <code>for</code>-loops iteration process and property delegates.</span></p>
</div>
<h3 id="a-call-without-an-explicit-receiver">A call without an explicit receiver</h3>
<div class="paragraph">
    <p><span class="sentence">A call that is performed with unqualified function name and without using a navigation operator is a call without an explicit receiver. </span><span class="sentence">It may in fact have one or more implicit receivers or be a top-level function.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">As with function calls with explicit receiver, a valid implementation should first pick a valid overload candidate set and then search this set for the <em>most specific function</em> to match the call.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">Than for a function named <code>f</code> the following sets are looked upon (in this order):</span></p>
</div>
<ol type="1">
    <li><span class="sentence">The sets of local non-extension functions named <code>f</code> available in current scope, in order of the scope they are declared in, smallest scope first;</span></li>
    <li><span class="sentence">The overload candidate sets for each implicit receiver and <code>f</code>, calculated as if it was the explicit receiver, in the order of the receiver priority (see previous section);</span></li>
    <li><span class="sentence">Top-level non-extension functions named <code>f</code>, in this order:</span>
        <ol type="a">
            <li><span class="sentence">Functions explicitely imported into current file;</span></li>
            <li><span class="sentence">Functions declared in the same package;</span></li>
            <li><span class="sentence">Functions star-imported into current file;</span></li>
            <li><span class="sentence">Implicitly imported functions (kotlin standard library or platform-specific);</span></li>
        </ol></li>
</ol>
<div class="paragraph">
    <p><span class="sentence">When looked upon these sets, the first set that contains <strong>any</strong> function with the corresponding name and conforming types is picked.</span></p>
</div>
<h3 id="calls-with-named-parameters">Calls with named parameters</h3>
<div class="paragraph">
    <p><span class="sentence">Most of the call forms listed above may use named parameters in call expressions, for example, <code>f(a = 2)</code>, where <code>a</code> is a named formal parameter specified in the declaration of <code>f</code>. </span><span class="sentence">Such calls are treated the same way as normal calls, but the overload resolution sets are filtered to only contain callables that actually have formal parameters for all the corresponding names.</span></p>
</div>
<blockquote>
    <div class="paragraph">
        <p><span class="sentence">For properties called through invoke-convention, the named parameters must be present in the declaration of the <code>invoke</code> operator function</span></p>
    </div>
</blockquote>
<div class="paragraph">
    <p><span class="sentence">Unlike positional arguments, named arguments specify directly which of the formal parameters of the function the argument corresponds to. </span><span class="sentence">The matching of formal parameters and arguments is performed separately for each function candidate and while the number of defaults ( see <a href="#choosing-the-most-specific-function-from-the-overload-candidate-set">the MSC definition process</a>) does affect resolution process, the fact that some argument was mapped using named or positional argument does not affect is in any way.</span></p>
</div>
<h3 id="calls-with-trailing-lambda-expressions">Calls with trailing lambda expressions</h3>
<div class="paragraph">
    <p><span class="sentence">Most of the call forms listed above may have a single lambda expression presented outside of the parentheses or replacing them (see [Call expression]). </span><span class="sentence">This has no effect on overload resolution process, aside from argument reordering that may happen due to variable argument parameters or parameters with defaults between the arguments.</span></p>
</div>
<blockquote>
    <div class="paragraph">
        <p><span class="sentence">This means that calls <code>f(1,2){ g() }</code> and <code>f(1,2, body = { g() })</code> are completely equivalent from the overload resolution standpoint, assuming that <code>body</code> is the name of the last formal parameter of <code>f</code></span></p>
    </div>
</blockquote>
<h3 id="choosing-the-most-specific-function-from-the-overload-candidate-set">Choosing the most specific function from the overload candidate set</h3>
<h4 id="rationale">Rationale</h4>
<div class="paragraph">
    <p><span class="sentence">The main rationale behind choosing the most specific function from a candidate set is that the function chosen could be easily forwarded to by all the other functions in the set, while the reverse is not true. </span><span class="sentence">If there are several functions with this property, none of them is the most specific and an ambiguity error should be reported by the compiler.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">Letâ€™s look at an example with two functions:</span></p>
</div>
<div class="sourceCode" id="cb14"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="kw">fun</span> <span class="fu">f</span>(<span class="va">arg</span>: <span class="dt">Int</span>, <span class="va">arg2</span>: <span class="dt">String</span>) {}        <span class="co">// (1)</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2"><span class="kw">fun</span> <span class="fu">f</span>(<span class="va">arg</span>: <span class="dt">Any?</span>, <span class="va">arg2</span>: <span class="dt">CharSequence</span>) {} <span class="co">// (2)</span></a>
<a class="sourceLine" id="cb14-3" data-line-number="3">...</a>
<a class="sourceLine" id="cb14-4" data-line-number="4">f(<span class="dv">2</span>, <span class="st">&quot;Hello&quot;</span>)</a></code></pre></div>
<div class="paragraph">
    <p><span class="sentence">Here both functions are applicable for the call, but also function (1) could easily call function (2) by forwarding both arguments into it, but the reverse is impossible. </span><span class="sentence">As a result, function (1) is more specific of the two. </span><span class="sentence">Letâ€™s rename the functions to make it more clear:</span></p>
</div>
<div class="sourceCode" id="cb15"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="kw">fun</span> <span class="fu">f1</span>(<span class="va">arg</span>: <span class="dt">Int</span>, <span class="va">arg2</span>: <span class="dt">String</span>) {</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">    f2(arg, arg2) <span class="co">// perfectly valid</span></a>
<a class="sourceLine" id="cb15-3" data-line-number="3">}</a>
<a class="sourceLine" id="cb15-4" data-line-number="4"><span class="kw">fun</span> <span class="fu">f2</span>(<span class="va">arg</span>: <span class="dt">Any?</span>, <span class="va">arg2</span>: <span class="dt">CharSequence</span>) {</a>
<a class="sourceLine" id="cb15-5" data-line-number="5">    f1(arg, arg2) <span class="co">// invalid: function f1 is not appicable</span></a>
<a class="sourceLine" id="cb15-6" data-line-number="6">}</a></code></pre></div>
<div class="paragraph">
    <p><span class="sentence">The rest of this section will try to clarify this mechanism a little more.</span></p>
</div>
<h4 id="formal-definition">Formal definition(?)</h4>
<div class="paragraph">
    <p><span class="sentence">One applicable function <span class="math inline">\(f_1\)</span> is <em>more specific</em> than other applicable function <span class="math inline">\(f_2\)</span> for an invocation with argument expressions <span class="math inline">\(e_1,e_2...e_K\)</span> if any of the following are true:</span></p>
</div>
<ul>
    <li><span class="sentence"><span class="math inline">\(f_2\)</span> has more formal parameters that are <strong>not</strong> specified in this call, including parameters with default values and variable argument parameters;</span></li>
    <li><span class="sentence"><span class="math inline">\(f_2\)</span> has variable argument formal parameters, while <span class="math inline">\(f_1\)</span> does not;</span></li>
    <li><span class="sentence"><span class="math inline">\(f_2\)</span> is not generic and all of the following holds:</span>
        <ul>
            <li><span class="sentence"><span class="math inline">\(f_1\)</span> has formal parameter types (including the receiver parameter, if any) <span class="math inline">\(S_1,S_2,S_3...S_N\)</span>;</span></li>
            <li><span class="sentence"><span class="math inline">\(f_2\)</span> has formal parameter types (including the receiver parameter, if any) <span class="math inline">\(T_1,T_2,T_3...T_N\)</span>;</span></li>
            <li><span class="sentence">Types <span class="math inline">\(S_1...S_K\)</span> are more specific for expressions <span class="math inline">\(e_1...e_K\)</span> than types <span class="math inline">\(T_1...T_K\)</span>.</span></li>
        </ul></li>
    <li><span class="sentence">TODO(): varargs</span></li>
</ul>
<div class="paragraph">
    <p><span class="sentence">The most specific function of a candidate set is the element of the set that is more specific than any other element of the set. </span><span class="sentence">If there is more than one such function, an ambiguity error should be reported.</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">A type S is more specific than type T for expression e if any of the following holds:</span></p>
</div>
<ul>
    <li><span class="sentence"><span class="math inline">\(S &lt;: T\)</span></span></li>
    <li><span class="sentence">S is <em>less generic</em> than T, meaning one of the following:</span>
        <ul>
            <li><span class="sentence">T is generic and S is not;</span></li>
            <li><span class="sentence">Both T and S are generic, but S has a bigger depth than S;</span></li>
        </ul></li>
</ul>
<div class="paragraph">
    <p><span class="sentence">TODO(): move it somewhere?</span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">The depth of a generic type is defined as follows: - A type parameter or non-generic type has depth 0; - A parameterized type <span class="math inline">\(G\)</span>&lt;<span class="math inline">\(T_0\)</span>,<span class="math inline">\(T_1\)</span>,<span class="math inline">\(T_2\)</span>,â€¦,<span class="math inline">\(T_N\)</span>&gt; has depth <span class="math inline">\(1 + max(depth(T_0), depth(T_1), depth(T_2), ... depth(T_N))\)</span></span></p>
</div>
<div class="paragraph">
    <p><span class="sentence">When calculating type depth, a generic type alias is treated the same way as its aliasee type.</span></p>
</div>
<blockquote>
    <div class="paragraph">
        <p><span class="sentence">Example 1: Letâ€™s suppose that T is type parameter A and S is List&lt;B&gt; where B is also a type parameter. </span><span class="sentence">As the depth of T is 0 and the depth of S is 1, S is less generic than T</span></p>
    </div>
</blockquote>
<blockquote>
    <div class="paragraph">
        <p><span class="sentence">Example 2: Letâ€™s suppose that T is function type A.(B) -&gt; C and S is function type (D) -&gt; (E) -&gt; F where A, B, C, D, E, F are all type parameters S is more specific than T because T has depth 1, while S has depth 2 (because function type is parameterized over its return type, which is also a parameterized function type)</span></p>
    </div>
</blockquote>
<h3 id="about-type-inference">About type inference</h3>
<div class="paragraph">
    <p><span class="sentence"><a href="#type-inference">Type inference</a> in Kotlin is a pretty complicated process, which is performed after resolving all the overload candidates. </span><span class="sentence">Due to the complexity of the process, type inference may not affect the way overload resolution candidate is picked up.</span></p>
</div>
<h4 id="todo-3">TODO:</h4>
<ul>
    <li><span class="sentence">Properties business</span></li>
    <li><span class="sentence">Definition of â€œapplicable functionâ€</span></li>
    <li><span class="sentence">Definition of â€œtype parameter levelâ€</span></li>
    <li><span class="sentence">Calls with named parameters <code>f(x = 2)</code></span></li>
    <li><span class="sentence">Calls with trailing lambda without parameter type</span>
        <ul>
            <li><span class="sentence">Lambdas with parameter types seem to be covered (or do they?)</span></li>
        </ul></li>
    <li><span class="sentence">Calls with specified type parameters <code>f&lt;Double&gt;(3)</code></span></li>
</ul>
<h2 id="concurrency">Concurrency</h2>
<div class="paragraph">
    <p><span class="sentence">TODO()</span></p>
</div>
<h2 id="coroutines">Coroutines</h2>
<div class="paragraph">
    <p><span class="sentence">TODO()</span></p>
</div>
<h2 id="annotations">Annotations</h2>
<div class="paragraph">
    <p><span class="sentence">TODO()</span></p>
</div>
<h2 id="documentation-comments">Documentation comments</h2>
<div class="paragraph">
    <p><span class="sentence">TODO()</span></p>
</div>
<h2 id="fubar">FUBAR</h2>
<div class="paragraph">
    <p><span class="sentence">TODO()</span></p>
</div>
</body>
</html>
